From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Andrew Yourtchenko <ayourtch@gmail.com>
Date: Wed, 18 Aug 2021 20:10:22 +0200
Subject: [PATCH 4/4] capo: Calico Policies plugin

New plugin that implements Calico policies and profiles in VPP.

Type: feature

Change-Id: I49d9c2ee985eb0d4a55ca672da9916dc4afa89ef
Signed-off-by: Andrew Yourtchenko <ayourtch@gmail.com>
Signed-off-by: Nathan Skrzypczak <nathan.skrzypczak@gmail.com>
Signed-off-by: Aloys Augustin <aloaugus@cisco.com>
Signed-off-by: MathiasRaoul <mathias.raoul@gmail.com>
---
 MAINTAINERS                        |   5 +
 src/plugins/capo/CMakeLists.txt    |  28 +
 src/plugins/capo/bihash_8_24.h     | 107 ++++
 src/plugins/capo/capo.api          | 260 ++++++++++
 src/plugins/capo/capo.h            |  58 +++
 src/plugins/capo/capo_api.c        | 443 ++++++++++++++++
 src/plugins/capo/capo_interface.c  | 339 ++++++++++++
 src/plugins/capo/capo_interface.h  |  41 ++
 src/plugins/capo/capo_ipset.c      | 472 +++++++++++++++++
 src/plugins/capo/capo_ipset.h      |  68 +++
 src/plugins/capo/capo_match.c      | 734 ++++++++++++++++++++++++++
 src/plugins/capo/capo_match.h      |  49 ++
 src/plugins/capo/capo_policy.c     | 263 ++++++++++
 src/plugins/capo/capo_policy.h     |  58 +++
 src/plugins/capo/capo_rule.c       | 509 ++++++++++++++++++
 src/plugins/capo/capo_rule.h       |  91 ++++
 src/plugins/capo/capo_test.c       | 490 ++++++++++++++++++
 src/plugins/capo/test/test_capo.py | 806 +++++++++++++++++++++++++++++
 18 files changed, 4821 insertions(+)
 create mode 100644 src/plugins/capo/CMakeLists.txt
 create mode 100644 src/plugins/capo/bihash_8_24.h
 create mode 100644 src/plugins/capo/capo.api
 create mode 100644 src/plugins/capo/capo.h
 create mode 100644 src/plugins/capo/capo_api.c
 create mode 100644 src/plugins/capo/capo_interface.c
 create mode 100644 src/plugins/capo/capo_interface.h
 create mode 100644 src/plugins/capo/capo_ipset.c
 create mode 100644 src/plugins/capo/capo_ipset.h
 create mode 100644 src/plugins/capo/capo_match.c
 create mode 100644 src/plugins/capo/capo_match.h
 create mode 100644 src/plugins/capo/capo_policy.c
 create mode 100644 src/plugins/capo/capo_policy.h
 create mode 100644 src/plugins/capo/capo_rule.c
 create mode 100644 src/plugins/capo/capo_rule.h
 create mode 100644 src/plugins/capo/capo_test.c
 create mode 100644 src/plugins/capo/test/test_capo.py

diff --git a/MAINTAINERS b/MAINTAINERS
index a1f8fed22..27ac4b72a 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -738,6 +738,11 @@ M:	Nathan Skrzypczak <nathan.skrzypczak@gmail.com>
 M:	Neale Ranns <neale@graphiant.com>
 F:	src/plugins/cnat
 
+Plugin - Calico policies
+I:	capo
+M:	Aloys Augustin <aloaugus@cisco.com>
+F:	src/plugins/capo/
+
 Plugin - Wireguard
 I:	wireguard
 M:	Artem Glazychev <artem.glazychev@xored.com>
diff --git a/src/plugins/capo/CMakeLists.txt b/src/plugins/capo/CMakeLists.txt
new file mode 100644
index 000000000..9fa10f710
--- /dev/null
+++ b/src/plugins/capo/CMakeLists.txt
@@ -0,0 +1,28 @@
+# Copyright (c) 2020 Cisco and/or its affiliates.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at:
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+add_vpp_plugin(capo
+  SOURCES
+  capo_api.c
+  capo_policy.c
+  capo_rule.c
+  capo_ipset.c
+  capo_match.c
+  capo_interface.c
+
+  API_TEST_SOURCES
+  capo_test.c
+
+  API_FILES
+  capo.api
+)
diff --git a/src/plugins/capo/bihash_8_24.h b/src/plugins/capo/bihash_8_24.h
new file mode 100644
index 000000000..79d1005bc
--- /dev/null
+++ b/src/plugins/capo/bihash_8_24.h
@@ -0,0 +1,107 @@
+/*
+ * Copyright (c) 2015 Cisco and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#undef BIHASH_TYPE
+#undef BIHASH_KVP_PER_PAGE
+#undef BIHASH_32_64_SVM
+#undef BIHASH_ENABLE_STATS
+#undef BIHASH_KVP_AT_BUCKET_LEVEL
+#undef BIHASH_LAZY_INSTANTIATE
+#undef BIHASH_BUCKET_PREFETCH_CACHE_LINES
+
+#define BIHASH_TYPE			   _8_24
+#define BIHASH_KVP_PER_PAGE		   4
+#define BIHASH_KVP_AT_BUCKET_LEVEL	   1
+#define BIHASH_LAZY_INSTANTIATE		   0
+#define BIHASH_BUCKET_PREFETCH_CACHE_LINES 2
+
+#ifndef __included_bihash_8_24_h__
+#define __included_bihash_8_24_h__
+
+#include <vppinfra/heap.h>
+#include <vppinfra/format.h>
+#include <vppinfra/pool.h>
+#include <vppinfra/xxhash.h>
+#include <vppinfra/crc32.h>
+
+/** 8 octet key, 32 octet key value pair */
+typedef struct
+{
+  u64 key;	/**< the key */
+  u64 value[3]; /**< the value */
+} clib_bihash_kv_8_24_t;
+
+/** Decide if a clib_bihash_kv_8_24_t instance is free
+    @param v- pointer to the (key,value) pair
+*/
+static inline int
+clib_bihash_is_free_8_24 (clib_bihash_kv_8_24_t *v)
+{
+  if (v->key == ~0ULL && v->value[0] == ~0ULL && v->value[1] == ~0ULL &&
+      v->value[2] == ~0ULL)
+    return 1;
+  return 0;
+}
+
+/** Hash a clib_bihash_kv_8_24_t instance
+    @param v - pointer to the (key,value) pair, hash the key (only)
+*/
+static inline u64
+clib_bihash_hash_8_24 (clib_bihash_kv_8_24_t *v)
+{
+  /* Note: to torture-test linear scan, make this fn return a constant */
+#ifdef clib_crc32c_uses_intrinsics
+  return clib_crc32c ((u8 *) &v->key, 8);
+#else
+  return clib_xxhash (v->key);
+#endif
+}
+
+/** Format a clib_bihash_kv_8_24_t instance
+    @param s - u8 * vector under construction
+    @param args (vararg) - the (key,value) pair to format
+    @return s - the u8 * vector under construction
+*/
+static inline u8 *
+format_bihash_kvp_8_24 (u8 *s, va_list *args)
+{
+  clib_bihash_kv_8_24_t *v = va_arg (*args, clib_bihash_kv_8_24_t *);
+
+  s = format (s, "key %lu value %lu %lu %lu", v->key, v->value[0], v->value[1],
+	      v->value[2]);
+  return s;
+}
+
+/** Compare two clib_bihash_kv_8_24_t instances
+    @param a - first key
+    @param b - second key
+*/
+static inline int
+clib_bihash_key_compare_8_24 (u64 a, u64 b)
+{
+  return a == b;
+}
+
+#undef __included_bihash_template_h__
+#include <vppinfra/bihash_template.h>
+
+#endif /* __included_bihash_8_24_h__ */
+
+/*
+ * fd.io coding-style-patch-verification: ON
+ *
+ * Local Variables:
+ * eval: (c-set-style "gnu")
+ * End:
+ */
diff --git a/src/plugins/capo/capo.api b/src/plugins/capo/capo.api
new file mode 100644
index 000000000..f29925e1d
--- /dev/null
+++ b/src/plugins/capo/capo.api
@@ -0,0 +1,260 @@
+/*
+ * Copyright (c) 2020 Cisco and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** \file
+    This file defines the vpp control-plane API messages
+    used to configure Calico policies
+*/
+
+option version = "0.1.0";
+import "vnet/ip/ip_types.api";
+import "vnet/fib/fib_types.api";
+
+/** \brief Get the plugin version
+    @param client_index - opaque cookie to identify the sender
+    @param context - sender context, to match reply w/ request
+*/
+
+define capo_get_version
+{
+  u32 client_index;
+  u32 context;
+};
+
+/** \brief Reply to get the plugin version
+    @param context - returned sender context, to match reply w/ request
+    @param major - Incremented every time a known breaking behavior change is introduced
+    @param minor - Incremented with small changes, may be used to avoid buggy versions
+*/
+
+define capo_get_version_reply
+{
+  u32 context;
+  u32 major;
+  u32 minor;
+};
+
+/** \brief Control ping from client to api server request
+    @param client_index - opaque cookie to identify the sender
+    @param context - sender context, to match reply w/ request
+*/
+define capo_control_ping
+{
+  u32 client_index;
+  u32 context;
+};
+
+/** \brief Control ping from the client to the server response
+    @param client_index - opaque cookie to identify the sender
+    @param context - sender context, to match reply w/ request
+    @param retval - return code for the request
+    @param vpe_pid - the pid of the vpe, returned by the server
+*/
+define capo_control_ping_reply
+{
+  u32 context;
+  i32 retval;
+  u32 client_index;
+  u32 vpe_pid;
+};
+
+
+enum capo_ipset_type : u8 {
+  CAPO_IP = 0,           /* Each member is an IP address */
+  CAPO_IP_AND_PORT = 1,  /* Each member is "<IP>,(tcp|udp):port" (3-tuple) */
+  CAPO_NET = 2,          /* Each member is a CIDR */
+};
+
+typedef capo_three_tuple {
+  vl_api_address_t address;
+  u8 l4_proto;
+  u16 port;
+};
+
+union capo_ipset_member_val {
+  vl_api_address_t address;
+  vl_api_prefix_t prefix;
+  vl_api_capo_three_tuple_t tuple;
+};
+
+typedef capo_ipset_member {
+  vl_api_capo_ipset_member_val_t val;
+};
+
+define capo_ipset_create
+{
+  u32 client_index;
+  u32 context;
+  vl_api_capo_ipset_type_t type;
+};
+
+define capo_ipset_create_reply
+{
+  u32 context;
+  i32 retval;
+  u32 set_id;
+};
+
+
+autoreply define capo_ipset_add_del_members
+{
+  u32 client_index;
+  u32 context;
+  u32 set_id;
+  bool is_add;
+  u32 len;
+  vl_api_capo_ipset_member_t members[len];
+};
+
+autoreply define capo_ipset_delete
+{
+  u32 client_index;
+  u32 context;
+  u32 set_id;
+};
+
+enum capo_rule_action : u8 {
+  CAPO_ALLOW = 0,  // Accept packet
+  CAPO_DENY,       // Drop / reject packet
+  CAPO_LOG,        // Ignored for now
+  CAPO_PASS,       // Skip following rules, resume evaluation at the policy
+                   // with the id configured in capo_configure_policies
+};
+
+enum capo_entry_type : u8 {
+  CAPO_CIDR = 0,     // simple prefix
+  CAPO_PORT_RANGE,
+  CAPO_PORT_IP_SET,  // Points to an ip + proto + port set
+  CAPO_IP_SET,       // Points to an ip only set
+};
+
+typedef capo_port_range {
+  u16 start;
+  u16 end;    // Inclusive, for a single port start==end
+};
+
+typedef capo_entry_set_id {
+  u32 set_id;
+};
+
+union capo_entry_data {
+  vl_api_prefix_t cidr;
+  vl_api_capo_port_range_t port_range;
+  vl_api_capo_entry_set_id_t set_id;
+};
+
+// A rule contains several such entries, each belong to a category
+// categories are: [not_]{src,dst}_{cidr,port_range,port_ip_set,ip_set}
+// (defined byt the 3 first fields in the rule_entry)
+// A rule matches a packet iff:
+// - for every "not" category, the source / destination do not match any entry
+// - for every positive match category, the source / destination matches at
+// least one entry in each category EXCEPT for port ranges and port+ip sets,
+// where the packet only needs to match one entry in either category
+
+typedef capo_rule_entry {
+  bool is_src;
+  bool is_not;
+  vl_api_capo_entry_type_t type;
+  vl_api_capo_entry_data_t data;
+};
+
+enum capo_rule_filter_type : u8 {
+  CAPO_RULE_FILTER_NONE_TYPE = 0,
+  CAPO_RULE_FILTER_ICMP_TYPE,
+  CAPO_RULE_FILTER_ICMP_CODE,
+  CAPO_RULE_FILTER_L4_PROTO,
+};
+
+typedef capo_rule_filter {
+  u32 value;
+  vl_api_capo_rule_filter_type_t type;
+  u8 should_match;
+};
+
+typedef capo_rule {
+  vl_api_address_family_t af;
+  vl_api_capo_rule_action_t action;
+  vl_api_capo_rule_filter_t filters[3];
+  u32 num_entries;
+  vl_api_capo_rule_entry_t matches[num_entries]; // List of other criteria
+};
+
+define capo_rule_create {
+  u32 client_index;
+  u32 context;
+  vl_api_capo_rule_t rule;
+};
+
+autoreply define capo_rule_update {
+  u32 client_index;
+  u32 context;
+  u32 rule_id;
+  vl_api_capo_rule_t rule;
+};
+
+define capo_rule_create_reply {
+  u32 context;
+  i32 retval;
+  u32 rule_id;
+};
+
+autoreply define capo_rule_delete {
+  u32 client_index;
+  u32 context;
+  u32 rule_id;
+};
+
+typedef capo_policy_item {
+  bool is_inbound; // 0 for outbound, 1 for is_inbound
+  u32 rule_id;
+};
+
+define capo_policy_create {
+  u32 client_index;
+  u32 context;
+  u32 num_items;
+  vl_api_capo_policy_item_t rules[num_items];
+};
+
+define capo_policy_create_reply {
+  u32 context;
+  i32 retval;
+  u32 policy_id;
+};
+
+autoreply define capo_policy_update {
+  u32 client_index;
+  u32 context;
+  u32 policy_id;
+  u32 num_items;
+  vl_api_capo_policy_item_t rules[num_items];
+};
+
+autoreply define capo_policy_delete {
+  u32 client_index;
+  u32 context;
+  u32 policy_id;
+};
+
+autoreply define capo_configure_policies {
+  u32 client_index;
+  u32 context;
+  u32 sw_if_index;
+  u32 num_rx_policies;
+  u32 num_tx_policies;
+  u32 total_ids;
+  u32 policy_ids[total_ids]; // rx_policies, then tx_policies, then profiles
+};
diff --git a/src/plugins/capo/capo.h b/src/plugins/capo/capo.h
new file mode 100644
index 000000000..812d14831
--- /dev/null
+++ b/src/plugins/capo/capo.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2020 Cisco and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef included_capo_h
+#define included_capo_h
+
+#include <vnet/ip/ip.h>
+#include <vnet/ip/ip_types_api.h>
+#include <acl/public_inlines.h>
+#include <capo/bihash_8_24.h>
+
+#include <capo/capo.api_enum.h>
+#include <capo/capo.api_types.h>
+#include <capo/capo_interface.h>
+
+#define CAPO_INVALID_INDEX ((u32) ~0)
+
+typedef struct
+{
+  u16 start;
+  u16 end;
+} capo_port_range_t;
+
+typedef struct
+{
+  clib_bihash_8_24_t if_config; /* sw_if_index -> capo_interface_config */
+
+  u32 calico_acl_user_id;
+  acl_plugin_methods_t acl_plugin;
+
+  /* API message ID base */
+  u16 msg_id_base;
+
+} capo_main_t;
+
+extern capo_main_t capo_main;
+
+#endif
+
+/*
+ * fd.io coding-style-patch-verification: ON
+ *
+ * Local Variables:
+ * eval: (c-set-style "gnu")
+ * End:
+ */
diff --git a/src/plugins/capo/capo_api.c b/src/plugins/capo/capo_api.c
new file mode 100644
index 000000000..335ed79cc
--- /dev/null
+++ b/src/plugins/capo/capo_api.c
@@ -0,0 +1,443 @@
+/*
+ * Copyright (c) 2020 Cisco and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <vnet/vnet.h>
+#include <vnet/plugin/plugin.h>
+#include <vlibapi/api.h>
+#include <vlibmemory/api.h>
+#include <vpp/app/version.h>
+#include <stdbool.h>
+
+#include <capo/capo.h>
+#include <capo/capo_rule.h>
+#include <capo/capo_policy.h>
+#include <capo/capo_ipset.h>
+#include <capo/capo_interface.h>
+
+#define REPLY_MSG_ID_BASE cpm->msg_id_base
+#include <vlibapi/api_helper_macros.h>
+
+#define CALICO_POLICY_VERSION_MAJOR 0
+#define CALICO_POLICY_VERSION_MINOR 0
+
+capo_main_t capo_main = { 0 };
+
+void
+capo_policy_rule_decode (const vl_api_capo_policy_item_t *in,
+			 capo_policy_rule_t *out)
+{
+  out->rule_id = clib_net_to_host_u32 (in->rule_id);
+  out->direction = in->is_inbound ? VLIB_RX : VLIB_TX;
+}
+
+int
+capo_ipset_member_decode (capo_ipset_type_t type,
+			  const vl_api_capo_ipset_member_t *in,
+			  capo_ipset_member_t *out)
+{
+  switch (type)
+    {
+    case IPSET_TYPE_IP:
+      ip_address_decode2 (&in->val.address, &out->address);
+      break;
+    case IPSET_TYPE_IPPORT:
+      ip_address_decode2 (&in->val.tuple.address, &out->ipport.addr);
+      out->ipport.l4proto = in->val.tuple.l4_proto;
+      out->ipport.port = clib_net_to_host_u16 (in->val.tuple.port);
+      break;
+    case IPSET_TYPE_NET:
+      return ip_prefix_decode2 (&in->val.prefix, &out->prefix);
+    }
+  return 0;
+}
+
+void
+capo_port_range_decode (const vl_api_capo_port_range_t *in,
+			capo_port_range_t *out)
+{
+  out->start = clib_net_to_host_u16 (in->start);
+  out->end = clib_net_to_host_u16 (in->end);
+}
+
+int
+capo_rule_entry_decode (const vl_api_capo_rule_entry_t *in,
+			capo_rule_entry_t *out)
+{
+  out->flags = 0;
+  if (in->is_src)
+    out->flags |= CAPO_IS_SRC;
+  if (in->is_not)
+    out->flags |= CAPO_IS_NOT;
+  out->type = (capo_entry_type_t) in->type;
+  switch (in->type)
+    {
+    case CAPO_CIDR:
+      return ip_prefix_decode2 (&in->data.cidr, &out->data.cidr);
+    case CAPO_PORT_RANGE:
+      capo_port_range_decode (&in->data.port_range, &out->data.port_range);
+      return 0;
+    case CAPO_PORT_IP_SET:
+    case CAPO_IP_SET:
+      out->data.set_id = clib_net_to_host_u32 (in->data.set_id.set_id);
+      return 0;
+    default:
+      return -1;
+    }
+}
+
+void
+capo_rule_filter_decode (const vl_api_capo_rule_filter_t *in,
+			 capo_rule_filter_t *out)
+{
+  out->type = (capo_rule_filter_type_t) in->type;
+  out->should_match = in->should_match;
+  out->value = clib_net_to_host_u32 (in->value);
+}
+
+static void
+vl_api_capo_get_version_t_handler (vl_api_capo_get_version_t *mp)
+{
+  capo_main_t *cpm = &capo_main;
+  vl_api_capo_get_version_reply_t *rmp;
+  int msg_size = sizeof (*rmp);
+  vl_api_registration_t *reg;
+
+  reg = vl_api_client_index_to_registration (mp->client_index);
+  if (!reg)
+    return;
+
+  rmp = vl_msg_api_alloc (msg_size);
+  clib_memset (rmp, 0, msg_size);
+  rmp->_vl_msg_id = ntohs (VL_API_CAPO_GET_VERSION_REPLY + cpm->msg_id_base);
+  rmp->context = mp->context;
+  rmp->major = htonl (CALICO_POLICY_VERSION_MAJOR);
+  rmp->minor = htonl (CALICO_POLICY_VERSION_MINOR);
+
+  vl_api_send_msg (reg, (u8 *) rmp);
+}
+
+static void
+vl_api_capo_control_ping_t_handler (vl_api_capo_control_ping_t *mp)
+{
+  capo_main_t *cpm = &capo_main;
+  vl_api_capo_control_ping_reply_t *rmp;
+  int rv = 0;
+
+  REPLY_MACRO2 (VL_API_CAPO_CONTROL_PING_REPLY,
+		({ rmp->vpe_pid = ntohl (getpid ()); }));
+}
+
+/* NAME: ipset_create */
+static void
+vl_api_capo_ipset_create_t_handler (vl_api_capo_ipset_create_t *mp)
+{
+  capo_main_t *cpm = &capo_main;
+  vl_api_capo_ipset_create_reply_t *rmp;
+  int rv = 0;
+  u32 id;
+
+  id = capo_ipset_create ((capo_ipset_type_t) mp->type);
+
+  REPLY_MACRO2 (VL_API_CAPO_IPSET_CREATE_REPLY,
+		({ rmp->set_id = clib_host_to_net_u32 (id); }));
+}
+
+/* NAME: ipset_add_del_members */
+static void
+vl_api_capo_ipset_add_del_members_t_handler (
+  vl_api_capo_ipset_add_del_members_t *mp)
+{
+  capo_main_t *cpm = &capo_main;
+  vl_api_capo_ipset_add_del_members_reply_t *rmp;
+  u32 set_id, i, n_members;
+  capo_ipset_type_t type;
+  int rv = 0;
+
+  set_id = clib_net_to_host_u32 (mp->set_id);
+  n_members = clib_net_to_host_u32 (mp->len);
+
+  rv = capo_ipset_get_type (set_id, &type);
+  if (rv)
+    goto done;
+
+  for (i = 0; i < n_members; i++)
+    {
+      capo_ipset_member_t _m, *member = &_m;
+      rv = capo_ipset_member_decode (type, &mp->members[i], member);
+      if (rv)
+	break;
+      if (mp->is_add)
+	rv = capo_ipset_add_member (set_id, member);
+      else
+	rv = capo_ipset_del_member (set_id, member);
+      if (rv)
+	break;
+    }
+
+done:
+  REPLY_MACRO (VL_API_CAPO_IPSET_ADD_DEL_MEMBERS_REPLY);
+}
+
+/* NAME: ipset_delete */
+static void
+vl_api_capo_ipset_delete_t_handler (vl_api_capo_ipset_delete_t *mp)
+{
+  capo_main_t *cpm = &capo_main;
+  vl_api_capo_ipset_delete_reply_t *rmp;
+  u32 set_id;
+  int rv;
+
+  set_id = clib_net_to_host_u32 (mp->set_id);
+  rv = capo_ipset_delete (set_id);
+
+  REPLY_MACRO (VL_API_CAPO_IPSET_DELETE_REPLY);
+}
+
+static int
+vl_api_capo_rule_update_create_handler (u32 *id, vl_api_capo_rule_t *rule)
+{
+  capo_rule_filter_t *filters = 0, *filter;
+  capo_rule_entry_t *entries = 0, *entry;
+  capo_rule_action_t action;
+  ip_address_family_t af = 0;
+  int rv;
+  u32 n_matches;
+  u32 i;
+
+  action = (capo_rule_action_t) rule->action;
+
+  // if ((rv = ip_address_family_decode (rule->af, &af)))
+  //   goto done;
+
+  for (i = 0; i < ARRAY_LEN (rule->filters); i++)
+    {
+      vec_add2 (filters, filter, 1);
+      capo_rule_filter_decode (&rule->filters[i], filter);
+    }
+
+  n_matches = clib_net_to_host_u32 (rule->num_entries);
+  for (i = 0; i < n_matches; i++)
+    {
+      vec_add2 (entries, entry, 1);
+      if ((rv = capo_rule_entry_decode (&rule->matches[i], entry)))
+	goto done;
+    }
+
+  rv = capo_rule_update (id, action, af, filters, entries);
+
+done:
+  vec_free (filters);
+  vec_free (entries);
+  return rv;
+}
+
+/* NAME: rule_create */
+static void
+vl_api_capo_rule_create_t_handler (vl_api_capo_rule_create_t *mp)
+{
+  vl_api_capo_rule_create_reply_t *rmp;
+  capo_main_t *cpm = &capo_main;
+  u32 id = CAPO_INVALID_INDEX;
+  int rv;
+
+  rv = vl_api_capo_rule_update_create_handler (&id, &mp->rule);
+
+  REPLY_MACRO2 (VL_API_CAPO_RULE_CREATE_REPLY,
+		({ rmp->rule_id = clib_host_to_net_u32 (id); }));
+}
+
+/* NAME: rule_update */
+static void
+vl_api_capo_rule_update_t_handler (vl_api_capo_rule_update_t *mp)
+{
+  vl_api_capo_rule_update_reply_t *rmp;
+  capo_main_t *cpm = &capo_main;
+  u32 id;
+  int rv;
+
+  id = clib_net_to_host_u32 (mp->rule_id);
+  rv = vl_api_capo_rule_update_create_handler (&id, &mp->rule);
+
+  REPLY_MACRO (VL_API_CAPO_RULE_UPDATE_REPLY);
+}
+
+/* NAME: rule_delete */
+static void
+vl_api_capo_rule_delete_t_handler (vl_api_capo_rule_delete_t *mp)
+{
+  vl_api_capo_rule_delete_reply_t *rmp;
+  capo_main_t *cpm = &capo_main;
+  u32 id;
+  int rv;
+
+  id = clib_net_to_host_u32 (mp->rule_id);
+  rv = capo_rule_delete (id);
+
+  REPLY_MACRO (VL_API_CAPO_RULE_DELETE_REPLY);
+}
+
+static int
+vl_api_capo_policy_update_create_handler (u32 *id, u32 n_rules,
+					  vl_api_capo_policy_item_t *api_rules)
+{
+  capo_policy_rule_t *rules = 0, *rule;
+  int rv;
+
+  for (u32 i = 0; i < n_rules; i++)
+    {
+      vec_add2 (rules, rule, 1);
+      capo_policy_rule_decode (&api_rules[i], rule);
+    }
+
+  rv = capo_policy_update (id, rules);
+
+  vec_free (rules);
+  return rv;
+}
+
+/* NAME: policy_create */
+static void
+vl_api_capo_policy_create_t_handler (vl_api_capo_policy_create_t *mp)
+{
+  vl_api_capo_policy_create_reply_t *rmp;
+  capo_main_t *cpm = &capo_main;
+  u32 id = CAPO_INVALID_INDEX, n_rules;
+  int rv;
+
+  n_rules = clib_net_to_host_u32 (mp->num_items);
+  rv = vl_api_capo_policy_update_create_handler (&id, n_rules, mp->rules);
+
+  REPLY_MACRO2 (VL_API_CAPO_POLICY_CREATE_REPLY,
+		({ rmp->policy_id = clib_host_to_net_u32 (id); }));
+}
+
+/* NAME: policy_update */
+static void
+vl_api_capo_policy_update_t_handler (vl_api_capo_policy_update_t *mp)
+{
+  vl_api_capo_policy_update_reply_t *rmp;
+  capo_main_t *cpm = &capo_main;
+  u32 id, n_rules;
+  int rv;
+
+  id = clib_net_to_host_u32 (mp->policy_id);
+  n_rules = clib_net_to_host_u32 (mp->num_items);
+  rv = vl_api_capo_policy_update_create_handler (&id, n_rules, mp->rules);
+
+  REPLY_MACRO (VL_API_CAPO_POLICY_UPDATE_REPLY);
+}
+
+/* NAME: policy_delete */
+static void
+vl_api_capo_policy_delete_t_handler (vl_api_capo_policy_delete_t *mp)
+{
+  vl_api_capo_policy_delete_reply_t *rmp;
+  capo_main_t *cpm = &capo_main;
+  u32 id;
+  int rv = 0;
+
+  id = clib_net_to_host_u32 (mp->policy_id);
+  rv = capo_policy_delete (id);
+
+  REPLY_MACRO (VL_API_CAPO_POLICY_DELETE_REPLY);
+}
+
+/* NAME: configure_policies */
+static void
+vl_api_capo_configure_policies_t_handler (vl_api_capo_configure_policies_t *mp)
+{
+  vl_api_capo_configure_policies_reply_t *rmp;
+  capo_main_t *cpm = &capo_main;
+  u32 num_profiles;
+  int rv = -1;
+  int i = 0;
+
+  mp->sw_if_index = clib_net_to_host_u32 (mp->sw_if_index);
+  mp->num_rx_policies = clib_net_to_host_u32 (mp->num_rx_policies);
+  mp->num_tx_policies = clib_net_to_host_u32 (mp->num_tx_policies);
+  mp->total_ids = clib_net_to_host_u32 (mp->total_ids);
+  num_profiles = mp->total_ids - mp->num_rx_policies - mp->num_tx_policies;
+  for (i = 0; i < mp->total_ids; i++)
+    {
+      mp->policy_ids[i] = clib_net_to_host_u32 (mp->policy_ids[i]);
+    }
+
+  rv = capo_configure_policies (mp->sw_if_index, mp->num_rx_policies,
+				mp->num_tx_policies, num_profiles,
+				mp->policy_ids);
+
+  REPLY_MACRO (VL_API_CAPO_CONFIGURE_POLICIES_REPLY);
+}
+
+/* Set up the API message handling tables */
+#include <vnet/format_fns.h>
+#include <capo/capo.api.c>
+
+#include <vat/vat.h>
+#include <vlibapi/vat_helper_macros.h>
+
+/* Declare message IDs */
+#include <acl/acl.api_enum.h>
+#include <acl/acl.api_types.h>
+#undef vl_print
+#define vl_print(handle, ...)
+#undef vl_print
+#define vl_endianfun /* define message structures */
+#include <acl/acl.api.h>
+#undef vl_endianfun
+
+static clib_error_t *
+calpol_init (vlib_main_t *vm)
+{
+  capo_main_t *cpm = &capo_main;
+
+  clib_error_t *acl_init_res = acl_plugin_exports_init (&cpm->acl_plugin);
+  if (acl_init_res)
+    return (acl_init_res);
+
+  cpm->calico_acl_user_id =
+    cpm->acl_plugin.register_user_module ("Calico Policy Plugin", NULL, NULL);
+
+  cpm->msg_id_base = setup_message_id_table ();
+
+  clib_bihash_init_8_24 (&cpm->if_config, "capo interfaces", 512, 1 << 20);
+
+  return (NULL);
+}
+
+static clib_error_t *
+calpol_plugin_config (vlib_main_t *vm, unformat_input_t *input)
+{
+  return NULL;
+}
+
+VLIB_PLUGIN_REGISTER () = {
+  .version = VPP_BUILD_VER,
+  .description = "Calico Policy",
+};
+
+VLIB_CONFIG_FUNCTION (calpol_plugin_config, "calico-policy-plugin");
+
+VLIB_INIT_FUNCTION (calpol_init) = {
+  .runs_after = VLIB_INITS ("acl_init"),
+};
+
+/*
+ * fd.io coding-style-patch-verification: ON
+ *
+ * Local Variables:
+ * eval: (c-set-style "gnu")
+ * End:
+ */
diff --git a/src/plugins/capo/capo_interface.c b/src/plugins/capo/capo_interface.c
new file mode 100644
index 000000000..6f9289383
--- /dev/null
+++ b/src/plugins/capo/capo_interface.c
@@ -0,0 +1,339 @@
+/*
+ * Copyright (c) 2020 Cisco and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <capo/capo.h>
+#include <capo/capo_match.h>
+#include <capo/capo_policy.h>
+
+uword unformat_sw_if_index (unformat_input_t *input, va_list *args);
+
+static int
+print_capo_interface2 (clib_bihash_kv_8_24_t *kv, void *arg)
+{
+  u8 **s = (u8 **) arg;
+  u32 sw_if_index = kv->key;
+  capo_interface_config_t *conf = (capo_interface_config_t *) kv->value;
+  *s = format (*s, "%U", format_capo_interface, sw_if_index, conf);
+  return BIHASH_WALK_CONTINUE;
+}
+
+void
+capo_interface_print_current_state ()
+{
+  u8 *s = 0;
+  clib_bihash_foreach_key_value_pair_8_24 (&capo_main.if_config,
+					   print_capo_interface2, (void *) &s);
+  clib_warning ("Current interface state:\n%s", s);
+  vec_free (s);
+}
+
+int
+capo_configure_policies (u32 sw_if_index, u32 num_rx_policies,
+			 u32 num_tx_policies, u32 num_profiles,
+			 u32 *policy_ids)
+{
+  clib_bihash_kv_8_24_t kv = { sw_if_index, { 0 } };
+  capo_interface_config_t *conf = (capo_interface_config_t *) &kv.value;
+  capo_interface_config_t *old_conf;
+  u32 found = 0, i = 0;
+
+  if (pool_is_free_index (vnet_get_main ()->interface_main.sw_interfaces,
+			  sw_if_index))
+    {
+      clib_warning (
+	"configuring policies for interface %u which doesn't exist",
+	sw_if_index);
+      return VNET_API_ERROR_INVALID_SW_IF_INDEX;
+    }
+
+  if (clib_bihash_search_8_24 (&capo_main.if_config, &kv, &kv) >= 0)
+    {
+      old_conf = (capo_interface_config_t *) &kv.value;
+      vec_free (old_conf->rx_policies);
+      vec_free (old_conf->tx_policies);
+      vec_free (old_conf->profiles);
+      found = 1;
+    }
+
+  for (i = 0; i < num_rx_policies + num_tx_policies + num_profiles; i++)
+    if (pool_is_free_index (capo_policies, policy_ids[i]))
+      goto error;
+
+  vec_resize (conf->rx_policies, num_rx_policies);
+  for (i = 0; i < num_rx_policies; i++)
+    conf->rx_policies[i] = policy_ids[i];
+  vec_resize (conf->tx_policies, num_tx_policies);
+  for (i = 0; i < num_tx_policies; i++)
+    conf->tx_policies[i] = policy_ids[num_rx_policies + i];
+  vec_resize (conf->profiles, num_profiles);
+  for (i = 0; i < num_profiles; i++)
+    conf->profiles[i] = policy_ids[num_rx_policies + num_tx_policies + i];
+
+  clib_bihash_add_del_8_24 (&capo_main.if_config, &kv, 1 /* is_add */);
+
+  if (!found)
+    {
+      capo_main.acl_plugin.wip_add_del_custom_access_io_policy (
+	1 /* is_add */, sw_if_index, 0 /* is_input */, capo_match_func);
+      capo_main.acl_plugin.wip_add_del_custom_access_io_policy (
+	1 /* is_add */, sw_if_index, 1 /* is_input */, capo_match_func);
+    }
+
+  capo_main.acl_plugin.wip_clear_sessions (sw_if_index);
+  return 0;
+
+error:
+  clib_warning ("error configuring policies for %u", sw_if_index);
+  vec_resize (conf->rx_policies, 0);
+  vec_resize (conf->tx_policies, 0);
+  vec_resize (conf->profiles, 0);
+  return 1;
+}
+
+static clib_error_t *
+capo_sw_interface_add_del (vnet_main_t *vnm, u32 sw_if_index, u32 is_add)
+{
+  clib_bihash_kv_8_24_t kv = { sw_if_index, { 0 } };
+  capo_interface_config_t *conf = (capo_interface_config_t *) &kv.value;
+  int rv = 0;
+
+  if (is_add)
+    return NULL;
+
+  if (clib_bihash_search_8_24 (&capo_main.if_config, &kv, &kv) >= 0)
+    {
+      conf = (capo_interface_config_t *) &kv.value;
+      vec_free (conf->rx_policies);
+      vec_free (conf->tx_policies);
+      vec_free (conf->profiles);
+    }
+
+  clib_warning ("unconfiguring policies for if %u deleted", sw_if_index);
+  clib_bihash_add_del_8_24 (&capo_main.if_config, &kv, 0 /* is_add */);
+  rv = capo_main.acl_plugin.wip_add_del_custom_access_io_policy (
+    0 /* is_add */, sw_if_index, 0 /* is_input */
+    ,
+    capo_match_func);
+  if (rv)
+    clib_warning ("error deleting caiop (output): %d", rv);
+  rv = capo_main.acl_plugin.wip_add_del_custom_access_io_policy (
+    0 /* is_add */, sw_if_index, 1 /* is_input */
+    ,
+    capo_match_func);
+  if (rv)
+    clib_warning ("error deleting caiop (input): %d", rv);
+  return NULL;
+}
+
+VNET_SW_INTERFACE_ADD_DEL_FUNCTION (capo_sw_interface_add_del);
+
+u8 *
+format_capo_interface (u8 *s, va_list *args)
+{
+  u32 sw_if_index = va_arg (*args, u32);
+  capo_interface_config_t *conf = va_arg (*args, capo_interface_config_t *);
+  vnet_main_t *vnm = vnet_get_main ();
+  capo_policy_t *policy = NULL;
+  u32 i;
+
+  s = format (s, "[%U sw_if_index=%u addr=", format_vnet_sw_if_index_name, vnm,
+	      sw_if_index, sw_if_index);
+  ip4_address_t *ip4 = 0;
+  ip4 = ip4_interface_first_address (&ip4_main, sw_if_index, 0);
+  if (ip4)
+    s = format (s, "%U", format_ip4_address, ip4);
+  s = format (s, "]\n");
+  if (vec_len (conf->rx_policies))
+    s = format (s, "  rx:\n");
+  vec_foreach_index (i, conf->rx_policies)
+    {
+      policy = capo_policy_get_if_exists (conf->rx_policies[i]);
+      s = format (s, "    %U", format_capo_policy, policy, 4 /* indent */,
+		  CAPO_POLICY_ONLY_RX);
+    }
+  if (vec_len (conf->tx_policies))
+    s = format (s, "  tx:\n");
+  vec_foreach_index (i, conf->tx_policies)
+    {
+      policy = capo_policy_get_if_exists (conf->tx_policies[i]);
+      s = format (s, "    %U", format_capo_policy, policy, 4 /* indent */,
+		  CAPO_POLICY_ONLY_TX);
+    }
+  if (vec_len (conf->profiles))
+    s = format (s, "  profiles:\n");
+  vec_foreach_index (i, conf->profiles)
+    {
+      policy = capo_policy_get_if_exists (conf->profiles[i]);
+      s = format (s, "    %U", format_capo_policy, policy, 4 /* indent */,
+		  CAPO_POLICY_VERBOSE);
+    }
+  return s;
+}
+
+int
+print_capo_interface (clib_bihash_kv_8_24_t *kv, void *arg)
+{
+  vlib_main_t *vm = (vlib_main_t *) arg;
+  u32 sw_if_index = kv->key;
+  capo_interface_config_t *conf = (capo_interface_config_t *) kv->value;
+  vlib_cli_output (vm, "%U", format_capo_interface, sw_if_index, conf);
+  return BIHASH_WALK_CONTINUE;
+}
+
+static clib_error_t *
+capo_interface_show_cmd_fn (vlib_main_t *vm, unformat_input_t *input,
+			    vlib_cli_command_t *cmd)
+{
+  vlib_cli_output (vm, "Interfaces with policies configured:");
+  clib_bihash_foreach_key_value_pair_8_24 (&capo_main.if_config,
+					   print_capo_interface, vm);
+  return NULL;
+}
+
+VLIB_CLI_COMMAND (capo_policies_show_cmd, static) = {
+  .path = "show capo interfaces",
+  .function = capo_interface_show_cmd_fn,
+  .short_help = "show capo interfaces",
+};
+
+static clib_error_t *
+capo_interface_clear_cmd_fn (vlib_main_t *vm, unformat_input_t *input,
+			     vlib_cli_command_t *cmd)
+{
+  unformat_input_t _line_input, *line_input = &_line_input;
+  clib_error_t *error = 0;
+  u32 sw_if_index = CAPO_INVALID_INDEX;
+  int rv;
+
+  if (!unformat_user (input, unformat_line_input, line_input))
+    return clib_error_return (0, "missing parameters");
+
+  while (unformat_check_input (line_input) != UNFORMAT_END_OF_INPUT)
+    {
+      if (unformat (line_input, "%U", unformat_sw_if_index, NULL,
+		    &sw_if_index))
+	;
+      else if (unformat (line_input, "sw_if_index %d", &sw_if_index))
+	;
+      else
+	{
+	  error = clib_error_return (0, "unknown input '%U'",
+				     format_unformat_error, line_input);
+	  goto done;
+	}
+    }
+
+  if (sw_if_index == CAPO_INVALID_INDEX)
+    {
+      error = clib_error_return (0, "interface not specified");
+      goto done;
+    }
+
+  rv = capo_configure_policies (sw_if_index, 0, 0, 0, NULL);
+  if (rv)
+    error =
+      clib_error_return (0, "capo_configure_policies errored with %d", rv);
+  else
+    vlib_cli_output (vm, "capo interface %d cleared", sw_if_index);
+
+done:
+  unformat_free (line_input);
+  return error;
+}
+
+VLIB_CLI_COMMAND (capo_interface_clear_cmd, static) = {
+  .path = "capo interface clear",
+  .function = capo_interface_clear_cmd_fn,
+  .short_help = "capo interface clear [interface | sw_if_index N]",
+};
+
+static clib_error_t *
+capo_interface_configure_cmd_fn (vlib_main_t *vm, unformat_input_t *input,
+				 vlib_cli_command_t *cmd)
+{
+  unformat_input_t _line_input, *line_input = &_line_input;
+  clib_error_t *error = 0;
+  u32 sw_if_index = CAPO_INVALID_INDEX;
+  u32 num_rx_policies = 0;
+  u32 num_tx_policies = 0;
+  u32 policy_id;
+  u32 *policy_list = NULL;
+  int rv;
+
+  if (!unformat_user (input, unformat_line_input, line_input))
+    return clib_error_return (0, "missing parameters");
+
+  while (unformat_check_input (line_input) != UNFORMAT_END_OF_INPUT)
+    {
+      if (unformat (line_input, "%U", unformat_sw_if_index, NULL,
+		    &sw_if_index))
+	;
+      else if (unformat (line_input, "sw_if_index %d", &sw_if_index))
+	;
+      else if (unformat (line_input, "rx %d", &num_rx_policies))
+	;
+      else if (unformat (line_input, "tx %d", &num_tx_policies))
+	;
+      else if (unformat (line_input, "%d", &policy_id))
+	vec_add1 (policy_list, policy_id);
+      else
+	{
+	  error = clib_error_return (0, "unknown input '%U'",
+				     format_unformat_error, line_input);
+	  goto done;
+	}
+    }
+
+  if (sw_if_index == CAPO_INVALID_INDEX)
+    {
+      error = clib_error_return (0, "interface not specified");
+      goto done;
+    }
+  if (!vec_len (policy_list))
+    {
+      error = clib_error_return (0, "no policies specified");
+      goto done;
+    }
+
+  rv = capo_configure_policies (
+    sw_if_index, num_rx_policies, num_tx_policies,
+    vec_len (policy_list) - num_rx_policies - num_tx_policies, policy_list);
+
+  if (rv)
+    error =
+      clib_error_return (0, "capo_configure_policies errored with %d", rv);
+  else
+    vlib_cli_output (vm, "capo interface %d configured", sw_if_index);
+
+done:
+  unformat_free (line_input);
+  vec_free (policy_list);
+  return error;
+}
+
+VLIB_CLI_COMMAND (capo_interface_configure_cmd, static) = {
+  .path = "capo interface configure",
+  .function = capo_interface_configure_cmd_fn,
+  .short_help = "capo interface configure [interface | sw_if_index N] rx "
+		"<num_rx> tx <num_tx> <policy_id> ...",
+};
+
+/*
+ * fd.io coding-style-patch-verification: ON
+ *
+ * Local Variables:
+ * eval: (c-set-style "gnu")
+ * End:
+ */
diff --git a/src/plugins/capo/capo_interface.h b/src/plugins/capo/capo_interface.h
new file mode 100644
index 000000000..b87bbcb4d
--- /dev/null
+++ b/src/plugins/capo/capo_interface.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2020 Cisco and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef included_capo_interface_h
+#define included_capo_interface_h
+
+#include <vppinfra/clib.h>
+
+typedef struct
+{
+  u32 *rx_policies;
+  u32 *tx_policies;
+  u32 *profiles;
+} capo_interface_config_t;
+
+int capo_configure_policies (u32 sw_if_index, u32 num_rx_policies,
+			     u32 num_tx_policies, u32 num_profiles,
+			     u32 *policy_ids);
+u8 *format_capo_interface (u8 *s, va_list *args);
+
+#endif
+
+/*
+ * fd.io coding-style-patch-verification: ON
+ *
+ * Local Variables:
+ * eval: (c-set-style "gnu")
+ * End:
+ */
diff --git a/src/plugins/capo/capo_ipset.c b/src/plugins/capo/capo_ipset.c
new file mode 100644
index 000000000..32db3b957
--- /dev/null
+++ b/src/plugins/capo/capo_ipset.c
@@ -0,0 +1,472 @@
+/*
+ * Copyright (c) 2020 Cisco and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <capo/capo.h>
+#include <capo/capo_ipset.h>
+
+capo_ipset_t *capo_ipsets;
+
+u8 *
+format_capo_ipport (u8 *s, va_list *args)
+{
+  capo_ipport_t *ipport = va_arg (*args, capo_ipport_t *);
+  return format (s, "%U %U;%u", format_ip_protocol, ipport->l4proto,
+		 format_ip_address, &ipport->addr, ipport->port);
+}
+
+u8 *
+format_capo_ipset_member (u8 *s, va_list *args)
+{
+  capo_ipset_member_t *member = va_arg (*args, capo_ipset_member_t *);
+  capo_ipset_type_t type = va_arg (*args, capo_ipset_type_t);
+  switch (type)
+    {
+    case IPSET_TYPE_IP:
+      return format (s, "%U", format_ip_address, &member->address);
+    case IPSET_TYPE_IPPORT:
+      return format (s, "%U", format_capo_ipport, &member->ipport);
+    case IPSET_TYPE_NET:
+      return format (s, "%U", format_ip_prefix, &member->prefix);
+    default:
+      return format (s, "unknown type");
+    }
+}
+
+uword
+unformat_capo_ipport (unformat_input_t *input, va_list *args)
+{
+  capo_ipport_t *ipport = va_arg (*args, capo_ipport_t *);
+  u32 proto;
+  u32 port;
+  if (unformat (input, "%U %U %d", unformat_ip_protocol, &proto,
+		unformat_ip_address, &ipport->addr, &port))
+    ;
+  else
+    return 0;
+
+  ipport->port = port;
+  ipport->l4proto = (u8) proto;
+  return 1;
+}
+
+u8 *
+format_capo_ipset_type (u8 *s, va_list *args)
+{
+  capo_ipset_type_t type = va_arg (*args, capo_ipset_type_t);
+  switch (type)
+    {
+    case IPSET_TYPE_IP:
+      return format (s, "ip");
+    case IPSET_TYPE_IPPORT:
+      return format (s, "ip+port");
+    case IPSET_TYPE_NET:
+      return format (s, "prefix");
+    default:
+      return format (s, "unknownipsettype");
+    }
+}
+
+uword
+unformat_capo_ipset_member (unformat_input_t *input, va_list *args)
+{
+  capo_ipset_member_t *member = va_arg (*args, capo_ipset_member_t *);
+  capo_ipset_type_t *type = va_arg (*args, capo_ipset_type_t *);
+  if (unformat_user (input, unformat_ip_prefix, &member->prefix))
+    *type = IPSET_TYPE_NET;
+  else if (unformat_user (input, unformat_ip_address, &member->address))
+    *type = IPSET_TYPE_IP;
+  else if (unformat_user (input, unformat_capo_ipport, &member->ipport))
+    *type = IPSET_TYPE_IPPORT;
+  else
+    return 0;
+
+  return 1;
+}
+
+u8 *
+format_capo_ipset (u8 *s, va_list *args)
+{
+  capo_ipset_t *ipset = va_arg (*args, capo_ipset_t *);
+  capo_ipset_member_t *member;
+
+  if (ipset == NULL)
+    return format (s, "deleted ipset");
+
+  s = format (s, "[ipset#%d;%U;", ipset - capo_ipsets, format_capo_ipset_type,
+	      ipset->type);
+
+  pool_foreach (member, ipset->members)
+    s = format (s, "%U,", format_capo_ipset_member, member, ipset->type);
+
+  s = format (s, "]");
+
+  return (s);
+}
+
+capo_ipset_t *
+capo_ipsets_get_if_exists (u32 index)
+{
+  if (pool_is_free_index (capo_ipsets, index))
+    return (NULL);
+  return pool_elt_at_index (capo_ipsets, index);
+}
+
+u32
+capo_ipset_create (capo_ipset_type_t type)
+{
+  capo_ipset_t *ipset;
+  pool_get (capo_ipsets, ipset);
+  ipset->type = type;
+  ipset->members = NULL;
+  return ipset - capo_ipsets;
+}
+
+int
+capo_ipset_delete (u32 id)
+{
+  capo_ipset_t *ipset;
+  ipset = capo_ipsets_get_if_exists (id);
+  if (NULL == ipset)
+    return VNET_API_ERROR_NO_SUCH_ENTRY;
+
+  pool_free (ipset->members);
+  pool_put (capo_ipsets, ipset);
+  return 0;
+}
+
+int
+capo_ipset_get_type (u32 id, capo_ipset_type_t *type)
+{
+  capo_ipset_t *ipset;
+  ipset = capo_ipsets_get_if_exists (id);
+  if (NULL == ipset)
+    return VNET_API_ERROR_NO_SUCH_ENTRY;
+
+  *type = ipset->type;
+  return 0;
+}
+
+int
+capo_ipset_add_member (u32 ipset_id, capo_ipset_member_t *member)
+{
+  capo_ipset_member_t *m;
+  capo_ipset_t *ipset = &capo_ipsets[ipset_id];
+
+  if (pool_is_free (capo_ipsets, ipset))
+    {
+      return 1;
+    }
+
+  /* zero so that we can memcmp later */
+  pool_get_zero (ipset->members, m);
+  clib_memcpy (m, member, sizeof (*m));
+  return 0;
+}
+
+static size_t
+capo_ipset_member_cmp (capo_ipset_member_t *m1, capo_ipset_member_t *m2,
+		       capo_ipset_type_t type)
+{
+  switch (type)
+    {
+    case IPSET_TYPE_IP:
+      return ip_address_cmp (&m1->address, &m2->address);
+    case IPSET_TYPE_IPPORT:
+      return ((m1->ipport.port == m2->ipport.port) &&
+	      (m1->ipport.l4proto == m2->ipport.l4proto) &&
+	      ip_address_cmp (&m1->ipport.addr, &m2->ipport.addr));
+    case IPSET_TYPE_NET:
+      return ip_prefix_cmp (&m1->prefix, &m2->prefix);
+    default:
+      return 1;
+    }
+}
+
+int
+capo_ipset_del_member (u32 id, capo_ipset_member_t *member)
+{
+  index_t *index, *indexes = NULL;
+  capo_ipset_member_t *m;
+  capo_ipset_t *ipset;
+
+  ipset = capo_ipsets_get_if_exists (id);
+  if (NULL == ipset)
+    return VNET_API_ERROR_NO_SUCH_ENTRY;
+
+  pool_foreach (m, ipset->members)
+    {
+      if (!capo_ipset_member_cmp (m, member, ipset->type))
+	vec_add1 (indexes, m - ipset->members);
+    }
+
+  vec_foreach (index, indexes)
+    pool_put_index (ipset->members, *index);
+  vec_free (indexes);
+
+  return 0;
+}
+
+static clib_error_t *
+capo_ipsets_show_cmd_fn (vlib_main_t *vm, unformat_input_t *input,
+			 vlib_cli_command_t *cmd)
+{
+  capo_ipset_t *ipset;
+
+  pool_foreach (ipset, capo_ipsets)
+    vlib_cli_output (vm, "%U", format_capo_ipset, ipset);
+
+  return 0;
+}
+
+VLIB_CLI_COMMAND (capo_ipsets_show_cmd, static) = {
+  .path = "show capo ipsets",
+  .function = capo_ipsets_show_cmd_fn,
+  .short_help = "show capo ipsets",
+};
+
+static clib_error_t *
+capo_ipsets_add_cmd_fn (vlib_main_t *vm, unformat_input_t *input,
+			vlib_cli_command_t *cmd)
+{
+  unformat_input_t _line_input, *line_input = &_line_input;
+  capo_ipset_member_t tmp, *members = 0, *member;
+  clib_error_t *error = 0;
+  capo_ipset_type_t type;
+  capo_ipset_t *ipset;
+  u32 id;
+  int rv;
+
+  id = capo_ipset_create ((capo_ipset_type_t) ~0);
+  vlib_cli_output (vm, "capo ipset %d added", id);
+
+  if (!unformat_user (input, unformat_line_input, line_input))
+    return 0;
+
+  while (unformat_check_input (line_input) != UNFORMAT_END_OF_INPUT)
+    {
+      if (unformat (line_input, "%U", unformat_capo_ipset_member, &tmp, &type))
+	vec_add1 (members, tmp);
+      else
+	{
+	  error = clib_error_return (0, "unknown input '%U'",
+				     format_unformat_error, line_input);
+	  goto done;
+	}
+    }
+
+  ipset = pool_elt_at_index (capo_ipsets, id);
+  ipset->type = type;
+
+  vec_foreach (member, members)
+    {
+      rv = capo_ipset_add_member (id, member);
+      if (rv)
+	error = clib_error_return (0, "capo_ipset_add_member error %d", rv);
+    }
+
+done:
+  vec_free (members);
+  unformat_free (line_input);
+  return error;
+}
+
+VLIB_CLI_COMMAND (capo_ipsets_add_cmd, static) = {
+  .path = "capo ipset add",
+  .function = capo_ipsets_add_cmd_fn,
+  .short_help = "capo ipset add [prefix|proto ip port|ip]",
+};
+
+static clib_error_t *
+capo_ipsets_del_cmd_fn (vlib_main_t *vm, unformat_input_t *input,
+			vlib_cli_command_t *cmd)
+{
+  unformat_input_t _line_input, *line_input = &_line_input;
+  clib_error_t *error = 0;
+  u32 id = CAPO_INVALID_INDEX;
+  int rv;
+
+  if (!unformat_user (input, unformat_line_input, line_input))
+    return clib_error_return (0, "missing ipset id");
+
+  while (unformat_check_input (line_input) != UNFORMAT_END_OF_INPUT)
+    {
+      if (unformat (line_input, "%u", &id))
+	;
+      else
+	{
+	  error = clib_error_return (0, "unknown input '%U'",
+				     format_unformat_error, line_input);
+	  goto done;
+	}
+    }
+
+  if (CAPO_INVALID_INDEX == id)
+    {
+      error = clib_error_return (0, "missing ipset id");
+      goto done;
+    }
+
+  rv = capo_ipset_delete (id);
+  if (rv)
+    error = clib_error_return (0, "capo_ipset_delete errored with %d", rv);
+
+done:
+  unformat_free (line_input);
+  return error;
+}
+
+VLIB_CLI_COMMAND (capo_ipsets_del_cmd, static) = {
+  .path = "capo ipset del",
+  .function = capo_ipsets_del_cmd_fn,
+  .short_help = "capo ipset del [id]",
+};
+
+static clib_error_t *
+capo_ipsets_add_member_cmd_fn (vlib_main_t *vm, unformat_input_t *input,
+			       vlib_cli_command_t *cmd)
+{
+  unformat_input_t _line_input, *line_input = &_line_input;
+  capo_ipset_member_t tmp, *members = 0, *member;
+  u32 id = CAPO_INVALID_INDEX;
+  clib_error_t *error = 0;
+  capo_ipset_type_t type;
+  capo_ipset_t *ipset;
+  int rv;
+
+  if (!unformat_user (input, unformat_line_input, line_input))
+    return clib_error_return (0, "missing parameters");
+
+  while (unformat_check_input (line_input) != UNFORMAT_END_OF_INPUT)
+    {
+      if (unformat (line_input, "id %u", &id))
+	;
+      else if (unformat (line_input, "%U", unformat_capo_ipset_member, &tmp,
+			 &type))
+	vec_add1 (members, tmp);
+      else
+	{
+	  error = clib_error_return (0, "unknown input '%U'",
+				     format_unformat_error, line_input);
+	  goto done;
+	}
+    }
+
+  if (CAPO_INVALID_INDEX == id)
+    {
+      error = clib_error_return (0, "missing ipset id");
+      goto done;
+    }
+
+  ipset = capo_ipsets_get_if_exists (id);
+  if (NULL == ipset)
+    return clib_error_return (0, "ipset not found");
+  if (ipset->type != type && ~0 != ipset->type)
+    {
+      error = clib_error_return (0, "cannot change ipset type");
+      goto done;
+    }
+  ipset->type = type;
+
+  vec_foreach (member, members)
+    {
+      rv = capo_ipset_add_member (id, member);
+      if (rv)
+	error = clib_error_return (0, "capo_ipset_add_member error %d", rv);
+    }
+
+done:
+  vec_free (members);
+  unformat_free (line_input);
+  return error;
+}
+
+VLIB_CLI_COMMAND (capo_ipsets_add_member_cmd, static) = {
+  .path = "capo ipset add member",
+  .function = capo_ipsets_add_member_cmd_fn,
+  .short_help = "capo ipset add member [id] [prefix]",
+};
+
+static clib_error_t *
+capo_ipsets_del_member_cmd_fn (vlib_main_t *vm, unformat_input_t *input,
+			       vlib_cli_command_t *cmd)
+{
+  unformat_input_t _line_input, *line_input = &_line_input;
+  clib_error_t *error = 0;
+  u32 id = CAPO_INVALID_INDEX;
+  capo_ipset_type_t type;
+  capo_ipset_member_t tmp, *members = 0, *member;
+  capo_ipset_t *ipset;
+  int rv;
+
+  if (!unformat_user (input, unformat_line_input, line_input))
+    return clib_error_return (0, "missing parameters");
+
+  while (unformat_check_input (line_input) != UNFORMAT_END_OF_INPUT)
+    {
+      if (unformat (line_input, "id %u", &id))
+	;
+      else if (unformat (line_input, "%U", unformat_capo_ipset_member, &tmp,
+			 &type))
+	vec_add1 (members, tmp);
+      else
+	{
+	  error = clib_error_return (0, "unknown input '%U'",
+				     format_unformat_error, line_input);
+	  goto done;
+	}
+    }
+
+  if (CAPO_INVALID_INDEX == id)
+    {
+      error = clib_error_return (0, "missing ipset id");
+      goto done;
+    }
+
+  ipset = capo_ipsets_get_if_exists (id);
+  if (NULL == ipset)
+    return clib_error_return (0, "ipset not found");
+  if (ipset->type != type)
+    {
+      error = clib_error_return (0, "wrong member type");
+      goto done;
+    }
+
+  vec_foreach (member, members)
+    {
+      rv = capo_ipset_del_member (id, member);
+      if (rv)
+	error =
+	  clib_error_return (0, "capo_ipset_del_member errored with %d", rv);
+    }
+
+done:
+  vec_free (members);
+  unformat_free (line_input);
+  return error;
+}
+
+VLIB_CLI_COMMAND (capo_ipsets_del_member_cmd, static) = {
+  .path = "capo ipset del member",
+  .function = capo_ipsets_del_member_cmd_fn,
+  .short_help = "capo ipset del member [id] [prefix]",
+};
+
+/*
+ * fd.io coding-style-patch-verification: ON
+ *
+ * Local Variables:
+ * eval: (c-set-style "gnu")
+ * End:
+ */
diff --git a/src/plugins/capo/capo_ipset.h b/src/plugins/capo/capo_ipset.h
new file mode 100644
index 000000000..56bb0f466
--- /dev/null
+++ b/src/plugins/capo/capo_ipset.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2020 Cisco and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef included_capo_ipset_h
+#define included_capo_ipset_h
+
+#include <capo/capo.h>
+
+typedef enum
+{
+  IPSET_TYPE_IP = 0,
+  IPSET_TYPE_IPPORT = 1,
+  IPSET_TYPE_NET = 2
+} capo_ipset_type_t;
+
+typedef struct
+{
+  ip_address_t addr;
+  u16 port;
+  u8 l4proto;
+} capo_ipport_t;
+
+typedef union
+{
+  ip_address_t address;
+  capo_ipport_t ipport;
+  ip_prefix_t prefix;
+} capo_ipset_member_t;
+
+typedef struct
+{
+  capo_ipset_type_t type;
+  capo_ipset_member_t *members;
+} capo_ipset_t;
+
+u32 capo_ipset_create (capo_ipset_type_t type);
+int capo_ipset_delete (u32 id);
+
+int capo_ipset_add_member (u32 ipset_id, capo_ipset_member_t *member);
+int capo_ipset_del_member (u32 ipset_id, capo_ipset_member_t *member);
+
+int capo_ipset_get_type (u32 id, capo_ipset_type_t *type);
+u8 *format_capo_ipset (u8 *s, va_list *args);
+capo_ipset_t *capo_ipsets_get_if_exists (u32 index);
+
+extern capo_ipset_t *capo_ipsets;
+
+#endif
+
+/*
+ * fd.io coding-style-patch-verification: ON
+ *
+ * Local Variables:
+ * eval: (c-set-style "gnu")
+ * End:
+ */
diff --git a/src/plugins/capo/capo_match.c b/src/plugins/capo/capo_match.c
new file mode 100644
index 000000000..59dfe826e
--- /dev/null
+++ b/src/plugins/capo/capo_match.c
@@ -0,0 +1,734 @@
+/*
+ * Copyright (c) 2020 Cisco and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <vnet/ip/ip.h>
+
+#include <capo/capo.h>
+#include <capo/capo_match.h>
+
+/* for our bihash 8_24 */
+#include <vppinfra/bihash_template.c>
+
+int
+capo_match_func (void *p_acl_main, u32 sw_if_index, u32 is_inbound,
+		 fa_5tuple_opaque_t *opaque_5tuple, int is_ip6, u8 *r_action,
+		 u32 *trace_bitmap)
+{
+  fa_5tuple_t *pkt_5tuple = (fa_5tuple_t *) opaque_5tuple;
+  clib_bihash_kv_8_24_t conf_kv;
+  capo_interface_config_t *if_config;
+  capo_policy_t *policy;
+  u32 *policies;
+  int r;
+  u32 i;
+
+  conf_kv.key = sw_if_index;
+  if (clib_bihash_search_8_24 (&capo_main.if_config, &conf_kv, &conf_kv) != 0)
+    {
+      /* no config for this interface found, allow */
+      *r_action = 2;
+      return 0;
+    }
+  if_config = (capo_interface_config_t *) conf_kv.value;
+  policies = is_inbound ? if_config->rx_policies : if_config->tx_policies;
+
+  if (vec_len (policies) == 0)
+    goto profiles; /* no policies, jump to profiles */
+
+  *r_action = 0; /* drop by default */
+
+  vec_foreach_index (i, policies)
+    {
+      policy = &capo_policies[policies[i]];
+      r = capo_match_policy (policy, is_inbound, is_ip6, pkt_5tuple);
+      switch (r)
+	{
+	case CAPO_ALLOW:
+	  *r_action = 2; /* allow */
+	  return 1;
+	case CAPO_DENY:
+	  return 1;
+	case CAPO_PASS:
+	  goto profiles;
+	case CAPO_LOG:
+	  /* TODO: support LOG action */
+	  break;
+	default:
+	  break;
+	}
+    };
+  /* nothing matched, deny */
+  return 1;
+
+profiles:
+  if (vec_len (if_config->profiles) == 0)
+    {
+      *r_action = 2; /* no profiles, allow */
+      return 1;
+    }
+
+  vec_foreach_index (i, if_config->profiles)
+    {
+      policy = &capo_policies[if_config->profiles[i]];
+      r = capo_match_policy (policy, is_inbound, is_ip6, pkt_5tuple);
+      switch (r)
+	{
+	case CAPO_ALLOW:
+	  *r_action = 2; /* allow */
+	  return 1;
+	case CAPO_DENY:
+	  return 1;
+	case CAPO_PASS:
+	  clib_warning ("error: pass in profile %u", if_config->profiles[i]);
+	  return 1;
+	case CAPO_LOG:
+	  /* TODO: support LOG action */
+	  break;
+	default:
+	  break;
+	}
+    };
+  /* nothing matched, deny */
+  return 1;
+}
+
+int
+capo_match_policy (capo_policy_t *policy, u32 is_inbound, u32 is_ip6,
+		   fa_5tuple_t *pkt_5tuple)
+{
+  /* packets RX/TX from VPP perspective */
+  u32 *rules =
+    is_inbound ? policy->rule_ids[VLIB_RX] : policy->rule_ids[VLIB_TX];
+  u32 *rule_id;
+  capo_rule_t *rule;
+  int r;
+
+  vec_foreach (rule_id, rules)
+    {
+      rule = &capo_rules[*rule_id];
+      r = capo_match_rule (rule, is_ip6, pkt_5tuple);
+      if (r >= 0)
+	{
+	  return r;
+	}
+    }
+  return -1;
+}
+
+#define SRC 0
+#define DST 1
+
+int
+capo_match_rule (capo_rule_t *rule, u32 is_ip6, fa_5tuple_t *pkt_5tuple)
+{
+  //   if (is_ip6 != (rule->af == AF_IP6)) {
+  //       return -1;
+  //   }
+
+  ip4_address_t *src_ip4 = &pkt_5tuple->ip4_addr[SRC];
+  ip4_address_t *dst_ip4 = &pkt_5tuple->ip4_addr[DST];
+  ip6_address_t *src_ip6 = &pkt_5tuple->ip6_addr[SRC];
+  ip6_address_t *dst_ip6 = &pkt_5tuple->ip6_addr[DST];
+  u8 l4proto = pkt_5tuple->l4.proto;
+  u16 src_port = pkt_5tuple->l4.port[SRC];
+  u16 dst_port = pkt_5tuple->l4.port[DST];
+  u16 type = pkt_5tuple->l4.port[0];
+  u16 code = pkt_5tuple->l4.port[1];
+
+  capo_rule_filter_t *filter;
+  vec_foreach (filter, rule->filters)
+    {
+      switch (filter->type)
+	{
+	case CAPO_RULE_FILTER_NONE_TYPE:
+	  break;
+	case CAPO_RULE_FILTER_L4_PROTO:
+	  if (filter->should_match && filter->value != l4proto)
+	    return -1;
+	  if (!filter->should_match && filter->value == l4proto)
+	    return -2;
+	  break;
+	case CAPO_RULE_FILTER_ICMP_TYPE:
+	  if (l4proto == IP_PROTOCOL_ICMP || l4proto == IP_PROTOCOL_ICMP6)
+	    {
+	      if (filter->should_match && filter->value != type)
+		return -3;
+	      if (!filter->should_match && filter->value == type)
+		return -4;
+	    }
+	  else
+	    // A rule with an ICMP type / code specified doesn't match a
+	    // non-icmp packet
+	    return -5;
+	  break;
+	case CAPO_RULE_FILTER_ICMP_CODE:
+	  if (l4proto == IP_PROTOCOL_ICMP || l4proto == IP_PROTOCOL_ICMP6)
+	    {
+	      if (filter->should_match && filter->value != code)
+		return -6;
+	      if (!filter->should_match && filter->value == code)
+		return -7;
+	    }
+	  else
+	    // A rule with an ICMP type / code specified doesn't match a
+	    // non-icmp packet
+	    return -8;
+	  break;
+	default:
+	  // clib_warning ("unimplemented capo filter!");
+	  break;
+	}
+    }
+
+  /* prefixes */
+  if (rule->prefixes[CAPO_SRC])
+    {
+      ip_prefix_t *prefix;
+      u8 found = 0;
+      vec_foreach (prefix, rule->prefixes[CAPO_SRC])
+	{
+	  u8 pfx_af = ip_prefix_version (prefix);
+	  if (is_ip6 && pfx_af == AF_IP6)
+	    {
+	      if (ip6_destination_matches_route (&ip6_main, src_ip6,
+						 &ip_addr_v6 (&prefix->addr),
+						 prefix->len))
+		{
+		  found = 1;
+		  break;
+		}
+	    }
+	  else if (!is_ip6 && pfx_af == AF_IP4)
+	    {
+	      if (ip4_destination_matches_route (&ip4_main, src_ip4,
+						 &ip_addr_v4 (&prefix->addr),
+						 prefix->len))
+		{
+		  found = 1;
+		  break;
+		}
+	    }
+	}
+      if (!found)
+	{
+	  return -9;
+	}
+    }
+
+  if (rule->prefixes[CAPO_NOT_SRC])
+    {
+      ip_prefix_t *prefix;
+      vec_foreach (prefix, rule->prefixes[CAPO_NOT_SRC])
+	{
+	  u8 pfx_af = ip_prefix_version (prefix);
+	  if (is_ip6 && pfx_af == AF_IP6)
+	    {
+	      if (ip6_destination_matches_route (&ip6_main, src_ip6,
+						 &ip_addr_v6 (&prefix->addr),
+						 prefix->len))
+		{
+		  return -10;
+		}
+	    }
+	  else if (!is_ip6 && pfx_af == AF_IP4)
+	    {
+	      if (ip4_destination_matches_route (&ip4_main, src_ip4,
+						 &ip_addr_v4 (&prefix->addr),
+						 prefix->len))
+		{
+		  return -11;
+		}
+	    }
+	}
+    }
+
+  if (rule->prefixes[CAPO_DST])
+    {
+      ip_prefix_t *prefix;
+      u8 found = 0;
+      vec_foreach (prefix, rule->prefixes[CAPO_DST])
+	{
+	  u8 pfx_af = ip_prefix_version (prefix);
+	  if (is_ip6 && pfx_af == AF_IP6)
+	    {
+	      if (ip6_destination_matches_route (&ip6_main, dst_ip6,
+						 &ip_addr_v6 (&prefix->addr),
+						 prefix->len))
+		{
+		  found = 1;
+		  break;
+		}
+	    }
+	  else if (!is_ip6 && pfx_af == AF_IP4)
+	    {
+	      if (ip4_destination_matches_route (&ip4_main, dst_ip4,
+						 &ip_addr_v4 (&prefix->addr),
+						 prefix->len))
+		{
+		  found = 1;
+		  break;
+		}
+	    }
+	}
+      if (!found)
+	{
+	  return -12;
+	}
+    }
+
+  if (rule->prefixes[CAPO_NOT_DST])
+    {
+      ip_prefix_t *prefix;
+      vec_foreach (prefix, rule->prefixes[CAPO_NOT_DST])
+	{
+	  u8 pfx_af = ip_prefix_version (prefix);
+	  if (is_ip6 && pfx_af == AF_IP6)
+	    {
+	      if (ip6_destination_matches_route (&ip6_main, dst_ip6,
+						 &ip_addr_v6 (&prefix->addr),
+						 prefix->len))
+		{
+		  return -13;
+		}
+	    }
+	  else if (!is_ip6 && pfx_af == AF_IP4)
+	    {
+	      if (ip4_destination_matches_route (&ip4_main, dst_ip4,
+						 &ip_addr_v4 (&prefix->addr),
+						 prefix->len))
+		{
+		  return -14;
+		}
+	    }
+	}
+    }
+
+  /* IP ipsets */
+  if (rule->ip_ipsets[CAPO_SRC])
+    {
+      u32 *ipset;
+      u8 found = 0;
+      vec_foreach (ipset, rule->ip_ipsets[CAPO_SRC])
+	{
+	  if (is_ip6)
+	    {
+	      if (ipset_contains_ip6 (&capo_ipsets[*ipset], src_ip6))
+		{
+		  found = 1;
+		  break;
+		}
+	    }
+	  else
+	    {
+	      if (ipset_contains_ip4 (&capo_ipsets[*ipset], src_ip4))
+		{
+		  found = 1;
+		  break;
+		}
+	    }
+	}
+      if (!found)
+	{
+	  return -15;
+	}
+    }
+
+  if (rule->ip_ipsets[CAPO_NOT_SRC])
+    {
+      u32 *ipset;
+      vec_foreach (ipset, rule->ip_ipsets[CAPO_NOT_SRC])
+	{
+	  if (is_ip6)
+	    {
+	      if (ipset_contains_ip6 (&capo_ipsets[*ipset], src_ip6))
+		{
+		  return -16;
+		}
+	    }
+	  else
+	    {
+	      if (ipset_contains_ip4 (&capo_ipsets[*ipset], src_ip4))
+		{
+		  return -17;
+		}
+	    }
+	}
+    }
+
+  if (rule->ip_ipsets[CAPO_DST])
+    {
+      u32 *ipset;
+      u8 found = 0;
+      vec_foreach (ipset, rule->ip_ipsets[CAPO_DST])
+	{
+	  if (is_ip6)
+	    {
+	      if (ipset_contains_ip6 (&capo_ipsets[*ipset], dst_ip6))
+		{
+		  found = 1;
+		  break;
+		}
+	    }
+	  else
+	    {
+	      if (ipset_contains_ip4 (&capo_ipsets[*ipset], dst_ip4))
+		{
+		  found = 1;
+		  break;
+		}
+	    }
+	}
+      if (!found)
+	{
+	  return -18;
+	}
+    }
+
+  if (rule->ip_ipsets[CAPO_NOT_DST])
+    {
+      u32 *ipset;
+      vec_foreach (ipset, rule->ip_ipsets[CAPO_NOT_DST])
+	{
+	  if (is_ip6)
+	    {
+	      if (ipset_contains_ip6 (&capo_ipsets[*ipset], dst_ip6))
+		{
+		  return -19;
+		}
+	    }
+	  else
+	    {
+	      if (ipset_contains_ip4 (&capo_ipsets[*ipset], dst_ip4))
+		{
+		  return -20;
+		}
+	    }
+	}
+    }
+
+  /* Special treatment for src / dst ports: they need to be in either the port
+     ranges or the port + ip ipsets / */
+  u8 src_port_found = 0;
+  u8 dst_port_found = 0;
+
+  /* port ranges */
+  if (rule->port_ranges[CAPO_SRC])
+    {
+      capo_port_range_t *range;
+      vec_foreach (range, rule->port_ranges[CAPO_SRC])
+	{
+	  if (range->start <= src_port && src_port <= range->end)
+	    {
+	      src_port_found = 1;
+	      break;
+	    }
+	}
+    }
+
+  if (rule->port_ranges[CAPO_NOT_SRC])
+    {
+      capo_port_range_t *range;
+      vec_foreach (range, rule->port_ranges[CAPO_NOT_SRC])
+	{
+	  if (range->start <= src_port && src_port <= range->end)
+	    {
+	      return -21;
+	    }
+	}
+    }
+
+  if (rule->port_ranges[CAPO_DST])
+    {
+      capo_port_range_t *range;
+      vec_foreach (range, rule->port_ranges[CAPO_DST])
+	{
+	  if (range->start <= dst_port && dst_port <= range->end)
+	    {
+	      dst_port_found = 1;
+	      break;
+	    }
+	}
+    }
+
+  if (rule->port_ranges[CAPO_NOT_DST])
+    {
+      capo_port_range_t *range;
+      vec_foreach (range, rule->port_ranges[CAPO_NOT_DST])
+	{
+	  if (range->start <= dst_port && dst_port <= range->end)
+	    {
+	      return -22;
+	    }
+	}
+    }
+
+  /* ipport ipsets */
+  if (rule->ipport_ipsets[CAPO_SRC])
+    {
+      u32 *ipset;
+      vec_foreach (ipset, rule->ipport_ipsets[CAPO_SRC])
+	{
+	  if (is_ip6)
+	    {
+	      if (ipport_ipset_contains_ip6 (&capo_ipsets[*ipset], src_ip6,
+					     l4proto, src_port))
+		{
+		  src_port_found = 1;
+		  break;
+		}
+	    }
+	  else
+	    {
+	      if (ipport_ipset_contains_ip4 (&capo_ipsets[*ipset], src_ip4,
+					     l4proto, src_port))
+		{
+		  src_port_found = 1;
+		  break;
+		}
+	    }
+	}
+    }
+
+  if (rule->ipport_ipsets[CAPO_NOT_SRC])
+    {
+      u32 *ipset;
+      vec_foreach (ipset, rule->ipport_ipsets[CAPO_NOT_SRC])
+	{
+	  if (is_ip6)
+	    {
+	      if (ipport_ipset_contains_ip6 (&capo_ipsets[*ipset], src_ip6,
+					     l4proto, src_port))
+		{
+		  return -23;
+		}
+	    }
+	  else
+	    {
+	      if (ipport_ipset_contains_ip4 (&capo_ipsets[*ipset], src_ip4,
+					     l4proto, src_port))
+		{
+		  return -24;
+		}
+	    }
+	}
+    }
+
+  if (rule->ipport_ipsets[CAPO_DST])
+    {
+      u32 *ipset;
+      vec_foreach (ipset, rule->ipport_ipsets[CAPO_DST])
+	{
+	  if (is_ip6)
+	    {
+	      if (ipport_ipset_contains_ip6 (&capo_ipsets[*ipset], dst_ip6,
+					     l4proto, dst_port))
+		{
+		  dst_port_found = 1;
+		  break;
+		}
+	    }
+	  else
+	    {
+	      if (ipport_ipset_contains_ip4 (&capo_ipsets[*ipset], dst_ip4,
+					     l4proto, dst_port))
+		{
+		  dst_port_found = 1;
+		  break;
+		}
+	    }
+	}
+    }
+
+  if (rule->ipport_ipsets[CAPO_NOT_DST])
+    {
+      u32 *ipset;
+      vec_foreach (ipset, rule->ipport_ipsets[CAPO_NOT_DST])
+	{
+	  if (is_ip6)
+	    {
+	      if (ipport_ipset_contains_ip6 (&capo_ipsets[*ipset], dst_ip6,
+					     l4proto, dst_port))
+		{
+		  return -25;
+		}
+	    }
+	  else
+	    {
+	      if (ipport_ipset_contains_ip4 (&capo_ipsets[*ipset], dst_ip4,
+					     l4proto, dst_port))
+		{
+		  return -26;
+		}
+	    }
+	}
+    }
+
+  if ((rule->port_ranges[CAPO_SRC] || rule->ipport_ipsets[CAPO_SRC]) &&
+      (!src_port_found))
+    {
+      return -27;
+    }
+  if ((rule->port_ranges[CAPO_DST] || rule->ipport_ipsets[CAPO_DST]) &&
+      (!dst_port_found))
+    {
+      return -28;
+    }
+
+  return rule->action;
+}
+
+u8
+ip_ipset_contains_ip4 (capo_ipset_t *ipset, ip4_address_t *addr)
+{
+  ASSERT (ipset->type == IPSET_TYPE_IP);
+  capo_ipset_member_t *member;
+  pool_foreach (member, ipset->members)
+    {
+      if (member->address.version != AF_IP4)
+	continue;
+      if (!ip4_address_compare (addr, &ip_addr_v4 (&member->address)))
+	return 1;
+    }
+  return 0;
+}
+
+u8
+ip_ipset_contains_ip6 (capo_ipset_t *ipset, ip6_address_t *addr)
+{
+  ASSERT (ipset->type == IPSET_TYPE_IP);
+  capo_ipset_member_t *member;
+  pool_foreach (member, ipset->members)
+    {
+      if (member->address.version != AF_IP6)
+	continue;
+      if (!ip6_address_compare (addr, &ip_addr_v6 (&member->address)))
+	return 1;
+    }
+  return 0;
+}
+
+u8
+net_ipset_contains_ip4 (capo_ipset_t *ipset, ip4_address_t *addr)
+{
+  ASSERT (ipset->type == IPSET_TYPE_NET);
+  capo_ipset_member_t *member;
+  pool_foreach (member, ipset->members)
+    {
+      if (member->prefix.addr.version != AF_IP4)
+	continue;
+      if (ip4_destination_matches_route (&ip4_main, addr,
+					 &ip_addr_v4 (&member->prefix.addr),
+					 member->prefix.len))
+	{
+	  return 1;
+	}
+    }
+  return 0;
+}
+
+u8
+net_ipset_contains_ip6 (capo_ipset_t *ipset, ip6_address_t *addr)
+{
+  ASSERT (ipset->type == IPSET_TYPE_NET);
+  capo_ipset_member_t *member;
+  pool_foreach (member, ipset->members)
+    {
+      if (member->prefix.addr.version != AF_IP6)
+	continue;
+      if (ip6_destination_matches_route (&ip6_main, addr,
+					 &ip_addr_v6 (&member->prefix.addr),
+					 member->prefix.len))
+	{
+	  return 1;
+	}
+    }
+  return 0;
+}
+
+u8
+ipset_contains_ip4 (capo_ipset_t *ipset, ip4_address_t *addr)
+{
+  switch (ipset->type)
+    {
+    case IPSET_TYPE_IP:
+      return ip_ipset_contains_ip4 (ipset, addr);
+    case IPSET_TYPE_NET:
+      return net_ipset_contains_ip4 (ipset, addr);
+    default:
+      clib_warning ("Wrong ipset type");
+    }
+  return 0;
+}
+
+u8
+ipset_contains_ip6 (capo_ipset_t *ipset, ip6_address_t *addr)
+{
+  switch (ipset->type)
+    {
+    case IPSET_TYPE_IP:
+      return ip_ipset_contains_ip6 (ipset, addr);
+    case IPSET_TYPE_NET:
+      return net_ipset_contains_ip6 (ipset, addr);
+    default:
+      clib_warning ("Wrong ipset type");
+    }
+  return 0;
+}
+
+u8
+ipport_ipset_contains_ip4 (capo_ipset_t *ipset, ip4_address_t *addr,
+			   u8 l4proto, u16 port)
+{
+  ASSERT (ipset->type == IPSET_TYPE_IPPORT);
+  capo_ipset_member_t *member;
+  pool_foreach (member, ipset->members)
+    {
+      if (member->ipport.addr.version != AF_IP4)
+	continue;
+      if (l4proto == member->ipport.l4proto && port == member->ipport.port &&
+	  !ip4_address_compare (addr, &ip_addr_v4 (&member->ipport.addr)))
+	{
+	  return 1;
+	}
+    }
+  return 0;
+}
+
+u8
+ipport_ipset_contains_ip6 (capo_ipset_t *ipset, ip6_address_t *addr,
+			   u8 l4proto, u16 port)
+{
+  ASSERT (ipset->type == IPSET_TYPE_IPPORT);
+  capo_ipset_member_t *member;
+  pool_foreach (member, ipset->members)
+    {
+      if (member->ipport.addr.version != AF_IP6)
+	continue;
+      if (l4proto == member->ipport.l4proto && port == member->ipport.port &&
+	  !ip6_address_compare (addr, &ip_addr_v6 (&member->ipport.addr)))
+	{
+	  return 1;
+	}
+    }
+  return 0;
+}
+
+/*
+ * fd.io coding-style-patch-verification: ON
+ *
+ * Local Variables:
+ * eval: (c-set-style "gnu")
+ * End:
+ */
diff --git a/src/plugins/capo/capo_match.h b/src/plugins/capo/capo_match.h
new file mode 100644
index 000000000..fe1907485
--- /dev/null
+++ b/src/plugins/capo/capo_match.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2020 Cisco and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef included_capo_match_h
+#define included_capo_match_h
+
+#include <acl/acl.h>
+#include <acl/fa_node.h>
+
+#include <capo/capo_ipset.h>
+#include <capo/capo_policy.h>
+#include <capo/capo_rule.h>
+
+int capo_match_func (void *p_acl_main, u32 sw_if_index, u32 is_inbound,
+		     fa_5tuple_opaque_t *opaque_5tuple, int is_ip6,
+		     u8 *r_action, u32 *trace_bitmap);
+
+int capo_match_policy (capo_policy_t *policy, u32 is_inbound, u32 is_ip6,
+		       fa_5tuple_t *pkt_5tuple);
+int capo_match_rule (capo_rule_t *rule, u32 is_ip6, fa_5tuple_t *pkt_5tuple);
+
+u8 ipset_contains_ip4 (capo_ipset_t *ipset, ip4_address_t *addr);
+u8 ipset_contains_ip6 (capo_ipset_t *ipset, ip6_address_t *addr);
+u8 ipport_ipset_contains_ip4 (capo_ipset_t *ipset, ip4_address_t *addr,
+			      u8 l4proto, u16 port);
+u8 ipport_ipset_contains_ip6 (capo_ipset_t *ipset, ip6_address_t *addr,
+			      u8 l4proto, u16 port);
+
+#endif
+
+/*
+ * fd.io coding-style-patch-verification: ON
+ *
+ * Local Variables:
+ * eval: (c-set-style "gnu")
+ * End:
+ */
diff --git a/src/plugins/capo/capo_policy.c b/src/plugins/capo/capo_policy.c
new file mode 100644
index 000000000..0e94400c3
--- /dev/null
+++ b/src/plugins/capo/capo_policy.c
@@ -0,0 +1,263 @@
+/*
+ * Copyright (c) 2020 Cisco and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <capo/capo.h>
+#include <capo/capo_policy.h>
+#include <capo/capo_rule.h>
+
+capo_policy_t *capo_policies;
+
+static capo_policy_t *
+capo_policy_alloc ()
+{
+  capo_policy_t *policy;
+  pool_get_zero (capo_policies, policy);
+  return policy;
+}
+
+capo_policy_t *
+capo_policy_get_if_exists (u32 index)
+{
+  if (pool_is_free_index (capo_policies, index))
+    return (NULL);
+  return pool_elt_at_index (capo_policies, index);
+}
+
+static void
+capo_policy_cleanup (capo_policy_t *policy)
+{
+  for (int i = 0; i < VLIB_N_RX_TX; i++)
+    vec_free (policy->rule_ids[i]);
+}
+
+int
+capo_policy_update (u32 *id, capo_policy_rule_t *rules)
+{
+  capo_policy_t *policy;
+  capo_policy_rule_t *rule;
+
+  policy = capo_policy_get_if_exists (*id);
+  if (policy)
+    capo_policy_cleanup (policy);
+  else
+    policy = capo_policy_alloc ();
+
+  vec_foreach (rule, rules)
+    vec_add1 (policy->rule_ids[rule->direction], rule->rule_id);
+
+  *id = policy - capo_policies;
+  return 0;
+}
+
+int
+capo_policy_delete (u32 id)
+{
+  capo_policy_t *policy;
+  policy = capo_policy_get_if_exists (id);
+  if (NULL == policy)
+    return VNET_API_ERROR_NO_SUCH_ENTRY;
+
+  capo_policy_cleanup (policy);
+  pool_put (capo_policies, policy);
+
+  return 0;
+}
+
+u8 *
+format_capo_policy (u8 *s, va_list *args)
+{
+  capo_policy_t *policy = va_arg (*args, capo_policy_t *);
+  int indent = va_arg (*args, int);
+  int verbose = va_arg (*args, int);
+  u32 *rule_id;
+
+  if (policy == NULL)
+    return format (s, "deleted policy");
+
+  if (verbose)
+    {
+      s = format (s, "[policy#%u]\n", policy - capo_policies);
+      capo_rule_t *rule;
+      if (verbose != CAPO_POLICY_ONLY_RX)
+	vec_foreach (rule_id, policy->rule_ids[VLIB_TX])
+	  {
+	    rule = capo_rule_get_if_exists (*rule_id);
+	    s = format (s, "%Utx:%U\n", format_white_space, indent + 2,
+			format_capo_rule, rule);
+	  }
+      if (verbose != CAPO_POLICY_ONLY_TX)
+	vec_foreach (rule_id, policy->rule_ids[VLIB_RX])
+	  {
+	    rule = capo_rule_get_if_exists (*rule_id);
+	    s = format (s, "%Urx:%U\n", format_white_space, indent + 2,
+			format_capo_rule, rule);
+	  }
+    }
+  else
+    {
+      s = format (s, "[policy#%u] rx-rules:%d tx-rules:%d\n",
+		  policy - capo_policies, vec_len (policy->rule_ids[VLIB_RX]),
+		  vec_len (policy->rule_ids[VLIB_TX]));
+    }
+
+  return (s);
+}
+
+static clib_error_t *
+capo_policies_show_cmd_fn (vlib_main_t *vm, unformat_input_t *input,
+			   vlib_cli_command_t *cmd)
+{
+  unformat_input_t _line_input, *line_input = &_line_input;
+  clib_error_t *error = 0;
+  capo_policy_t *policy;
+  u8 verbose = 0, has_input = 0;
+
+  if (unformat_user (input, unformat_line_input, line_input))
+    {
+      has_input = 1;
+      while (unformat_check_input (line_input) != UNFORMAT_END_OF_INPUT)
+	{
+	  if (unformat (line_input, "verbose"))
+	    verbose = 1;
+	  else
+	    {
+	      error = clib_error_return (0, "unknown input '%U'",
+					 format_unformat_error, line_input);
+	      goto done;
+	    }
+	}
+    }
+
+  pool_foreach (policy, capo_policies)
+    vlib_cli_output (vm, "%U", format_capo_policy, policy, 0 /* indent */,
+		     verbose);
+
+done:
+  if (has_input)
+    unformat_free (line_input);
+  return error;
+}
+
+VLIB_CLI_COMMAND (capo_policies_show_cmd, static) = {
+  .path = "show capo policies",
+  .function = capo_policies_show_cmd_fn,
+  .short_help = "show capo policies [verbose]",
+};
+
+static clib_error_t *
+capo_policies_add_cmd_fn (vlib_main_t *vm, unformat_input_t *input,
+			  vlib_cli_command_t *cmd)
+{
+  unformat_input_t _line_input, *line_input = &_line_input;
+  clib_error_t *error = 0;
+  u32 id = CAPO_INVALID_INDEX, rule_id;
+  capo_policy_rule_t *policy_rules = 0, *policy_rule;
+  int direction = VLIB_RX;
+  int rv;
+
+  if (!unformat_user (input, unformat_line_input, line_input))
+    return clib_error_return (0, "missing parameters");
+
+  while (unformat_check_input (line_input) != UNFORMAT_END_OF_INPUT)
+    {
+      if (unformat (line_input, "update %u", &id))
+	;
+      else if (unformat (line_input, "%U", unformat_vlib_rx_tx, &direction))
+	;
+      else if (unformat (line_input, "%u", &rule_id))
+	{
+	  vec_add2 (policy_rules, policy_rule, 1);
+	  policy_rule->rule_id = rule_id;
+	  policy_rule->direction = direction;
+	}
+      else
+	{
+	  error = clib_error_return (0, "unknown input '%U'",
+				     format_unformat_error, line_input);
+	  goto done;
+	}
+    }
+
+  rv = capo_policy_update (&id, policy_rules);
+  if (rv)
+    error = clib_error_return (0, "capo_policy_delete errored with %d", rv);
+  else
+    vlib_cli_output (vm, "capo policy %d added", id);
+
+done:
+  vec_free (policy_rules);
+  unformat_free (line_input);
+  return error;
+}
+
+VLIB_CLI_COMMAND (capo_policies_add_cmd, static) = {
+  .path = "capo policy add",
+  .function = capo_policies_add_cmd_fn,
+  .short_help = "capo policy add [rx rule_id rule_id ...] [tx rule_id rule_id "
+		"...] [update [id]]",
+};
+
+static clib_error_t *
+capo_policies_del_cmd_fn (vlib_main_t *vm, unformat_input_t *input,
+			  vlib_cli_command_t *cmd)
+{
+  unformat_input_t _line_input, *line_input = &_line_input;
+  clib_error_t *error = 0;
+  u32 id = CAPO_INVALID_INDEX;
+  int rv;
+
+  if (!unformat_user (input, unformat_line_input, line_input))
+    return clib_error_return (0, "missing policy id");
+
+  while (unformat_check_input (line_input) != UNFORMAT_END_OF_INPUT)
+    {
+      if (unformat (line_input, "%u", &id))
+	;
+      else
+	{
+	  error = clib_error_return (0, "unknown input '%U'",
+				     format_unformat_error, line_input);
+	  goto done;
+	}
+    }
+
+  if (CAPO_INVALID_INDEX == id)
+    {
+      error = clib_error_return (0, "missing policy id");
+      goto done;
+    }
+
+  rv = capo_policy_delete (id);
+  if (rv)
+    error = clib_error_return (0, "capo_policy_delete errored with %d", rv);
+
+done:
+  unformat_free (line_input);
+  return error;
+}
+
+VLIB_CLI_COMMAND (capo_policies_del_cmd, static) = {
+  .path = "capo policy del",
+  .function = capo_policies_del_cmd_fn,
+  .short_help = "capo policy del [id]",
+};
+
+/*
+ * fd.io coding-style-patch-verification: ON
+ *
+ * Local Variables:
+ * eval: (c-set-style "gnu")
+ * End:
+ */
diff --git a/src/plugins/capo/capo_policy.h b/src/plugins/capo/capo_policy.h
new file mode 100644
index 000000000..c598f9ade
--- /dev/null
+++ b/src/plugins/capo/capo_policy.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2020 Cisco and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef included_capo_policy_h
+#define included_capo_policy_h
+
+#include <capo/capo.h>
+
+typedef struct
+{
+  /* VLIB_RX for inbound
+     VLIB_TX for outbound */
+  u32 *rule_ids[VLIB_N_RX_TX];
+} capo_policy_t;
+
+typedef struct
+{
+  u32 rule_id;
+  /* VLIB_RX or VLIB_TX */
+  u8 direction;
+} capo_policy_rule_t;
+
+typedef enum
+{
+  CAPO_POLICY_QUIET,
+  CAPO_POLICY_VERBOSE,
+  CAPO_POLICY_ONLY_RX,
+  CAPO_POLICY_ONLY_TX,
+} capo_policy_format_type_t;
+
+extern capo_policy_t *capo_policies;
+
+int capo_policy_update (u32 *id, capo_policy_rule_t *rules);
+int capo_policy_delete (u32 id);
+u8 *format_capo_policy (u8 *s, va_list *args);
+capo_policy_t *capo_policy_get_if_exists (u32 index);
+
+#endif
+
+/*
+ * fd.io coding-style-patch-verification: ON
+ *
+ * Local Variables:
+ * eval: (c-set-style "gnu")
+ * End:
+ */
diff --git a/src/plugins/capo/capo_rule.c b/src/plugins/capo/capo_rule.c
new file mode 100644
index 000000000..c672f29bd
--- /dev/null
+++ b/src/plugins/capo/capo_rule.c
@@ -0,0 +1,509 @@
+/*
+ * Copyright (c) 2020 Cisco and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <capo/capo.h>
+#include <capo/capo_rule.h>
+#include <capo/capo_ipset.h>
+
+capo_rule_t *capo_rules;
+
+u8 *
+format_capo_rule_action (u8 *s, va_list *args)
+{
+  capo_rule_action_t action = va_arg (*args, int);
+  switch (action)
+    {
+    case CAPO_ALLOW:
+      return format (s, "allow");
+    case CAPO_DENY:
+      return format (s, "deny");
+    case CAPO_LOG:
+      return format (s, "log");
+    case CAPO_PASS:
+      return format (s, "pass");
+    default:
+      return format (s, "unknownaction");
+    }
+}
+
+uword
+unformat_capo_rule_action (unformat_input_t *input, va_list *args)
+{
+  capo_rule_action_t *action = va_arg (*args, capo_rule_action_t *);
+  if (unformat (input, "allow"))
+    *action = CAPO_ALLOW;
+  else if (unformat (input, "deny"))
+    *action = CAPO_DENY;
+  else if (unformat (input, "log"))
+    *action = CAPO_LOG;
+  else if (unformat (input, "pass"))
+    *action = CAPO_PASS;
+  else
+    return 0;
+  return 1;
+}
+
+u8 *
+format_capo_rule_port_range (u8 *s, va_list *args)
+{
+  capo_port_range_t *port_range = va_arg (*args, capo_port_range_t *);
+
+  if (port_range->start != port_range->end)
+    s = format (s, "[%u-%u]", port_range->start, port_range->end);
+  else
+    s = format (s, "%u", port_range->start);
+
+  return (s);
+}
+
+u8 *
+format_capo_rule_entry (u8 *s, va_list *args)
+{
+  capo_rule_entry_t *entry = va_arg (*args, capo_rule_entry_t *);
+  capo_ipset_t *ipset;
+
+  s = format (s, "%s", entry->flags & CAPO_IS_SRC ? "src" : "dst");
+  s = format (s, "%s", entry->flags & CAPO_IS_NOT ? "!=" : "==");
+  switch (entry->type)
+    {
+    case CAPO_CIDR:
+      s = format (s, "%U", format_ip_prefix, &entry->data.cidr);
+      break;
+    case CAPO_PORT_RANGE:
+      s =
+	format (s, "%U", format_capo_rule_port_range, &entry->data.port_range);
+      break;
+    case CAPO_IP_SET:
+      ipset = capo_ipsets_get_if_exists (entry->data.set_id);
+      s = format (s, "%U", format_capo_ipset, ipset);
+      break;
+    case CAPO_PORT_IP_SET:
+      ipset = capo_ipsets_get_if_exists (entry->data.set_id);
+      s = format (s, "%U", format_capo_ipset, ipset);
+      break;
+    default:
+      s = format (s, "unknown");
+      break;
+    }
+  return (s);
+}
+
+uword
+unformat_rule_key_flag (unformat_input_t *input, va_list *args)
+{
+  capo_rule_key_flag_t *flags = va_arg (*args, capo_rule_key_flag_t *);
+  if (unformat (input, "src=="))
+    *flags = CAPO_IS_SRC;
+  else if (unformat (input, "src!="))
+    *flags = CAPO_IS_SRC | CAPO_IS_NOT;
+  else if (unformat (input, "dst!="))
+    *flags = CAPO_IS_NOT;
+  else if (unformat (input, "dst=="))
+    *flags = 0;
+  else
+    return 0;
+  return 1;
+}
+
+uword
+unformat_capo_port_range (unformat_input_t *input, va_list *args)
+{
+  capo_port_range_t *port_range = va_arg (*args, capo_port_range_t *);
+  u32 start, end;
+  if (unformat (input, "[%d-%d]", &start, &end))
+    {
+      port_range->start = (u16) start;
+      port_range->end = (u16) end;
+    }
+  else
+    return 0;
+  return 1;
+}
+
+uword
+unformat_capo_rule_entry (unformat_input_t *input, va_list *args)
+{
+  capo_rule_entry_t *entry = va_arg (*args, capo_rule_entry_t *);
+  if (unformat (input, "%U %U", unformat_rule_key_flag, &entry->flags,
+		unformat_ip_prefix, &entry->data.cidr))
+    entry->type = CAPO_CIDR;
+  else if (unformat (input, "%U %U", unformat_rule_key_flag, &entry->flags,
+		     unformat_capo_port_range, &entry->data.port_range))
+    entry->type = CAPO_PORT_RANGE;
+  else if (unformat (input, "%Uset %u", unformat_rule_key_flag, &entry->flags,
+		     &entry->data.set_id))
+    entry->type = CAPO_PORT_IP_SET;
+  else
+    return 0;
+  return 1;
+}
+
+u8 *
+format_capo_rule_filter (u8 *s, va_list *args)
+{
+  capo_rule_filter_t *filter = va_arg (*args, capo_rule_filter_t *);
+  switch (filter->type)
+    {
+    case CAPO_RULE_FILTER_NONE_TYPE:
+      return format (s, "<no filter>");
+    case CAPO_RULE_FILTER_ICMP_TYPE:
+      return format (s, "icmp-type%s=%d", filter->should_match ? "=" : "!",
+		     filter->value);
+    case CAPO_RULE_FILTER_ICMP_CODE:
+      return format (s, "icmp-code%s=%d", filter->should_match ? "=" : "!",
+		     filter->value);
+    case CAPO_RULE_FILTER_L4_PROTO:
+      return format (s, "proto%s=%U", filter->should_match ? "=" : "!",
+		     format_ip_protocol, filter->value);
+    default:
+      return format (s, "unknown");
+    }
+}
+
+uword
+unformat_capo_should_match (unformat_input_t *input, va_list *args)
+{
+  u8 *should_match = va_arg (*args, u8 *);
+  if (unformat (input, "=="))
+    *should_match = 1;
+  else if (unformat (input, "!="))
+    *should_match = 0;
+  else
+    return 0;
+  return 1;
+}
+
+uword
+unformat_capo_rule_filter (unformat_input_t *input, va_list *args)
+{
+  u8 tmp_value;
+  capo_rule_filter_t *filter = va_arg (*args, capo_rule_filter_t *);
+  if (unformat (input, "icmp-type%U%d", unformat_capo_should_match,
+		&filter->should_match, &filter->value))
+    filter->type = CAPO_RULE_FILTER_ICMP_TYPE;
+  else if (unformat (input, "icmp-code%U%d", unformat_capo_should_match,
+		     &filter->should_match, &filter->value))
+    filter->type = CAPO_RULE_FILTER_ICMP_CODE;
+  else if (unformat (input, "proto%U%U", unformat_capo_should_match,
+		     &filter->should_match, unformat_ip_protocol, &tmp_value))
+    {
+      filter->value = tmp_value;
+      filter->type = CAPO_RULE_FILTER_L4_PROTO;
+    }
+  else
+    return 0;
+  return 1;
+}
+
+static capo_rule_entry_t *
+capo_rule_get_entries (capo_rule_t *rule)
+{
+  capo_rule_entry_t *entries = NULL, *entry;
+  capo_port_range_t *pr;
+  ip_prefix_t *pfx;
+  u32 *set_id;
+  for (int i = 0; i < CAPO_RULE_MAX_FLAGS; i++)
+    {
+      vec_foreach (pfx, rule->prefixes[i])
+	{
+	  vec_add2 (entries, entry, 1);
+	  entry->type = CAPO_CIDR;
+	  entry->flags = i;
+	  clib_memcpy (&entry->data.cidr, pfx, sizeof (*pfx));
+	}
+      vec_foreach (pr, rule->port_ranges[i])
+	{
+	  vec_add2 (entries, entry, 1);
+	  entry->type = CAPO_PORT_RANGE;
+	  entry->flags = i;
+	  clib_memcpy (&entry->data.port_range, pr, sizeof (*pr));
+	}
+      vec_foreach (set_id, rule->ip_ipsets[i])
+	{
+	  vec_add2 (entries, entry, 1);
+	  entry->type = CAPO_IP_SET;
+	  entry->flags = i;
+	  entry->data.set_id = *set_id;
+	}
+      vec_foreach (set_id, rule->ipport_ipsets[i])
+	{
+	  vec_add2 (entries, entry, 1);
+	  entry->type = CAPO_PORT_IP_SET;
+	  entry->flags = i;
+	  entry->data.set_id = *set_id;
+	}
+    }
+  return entries;
+}
+
+u8 *
+format_capo_rule (u8 *s, va_list *args)
+{
+  capo_rule_t *rule = va_arg (*args, capo_rule_t *);
+  capo_rule_filter_t *filter;
+  capo_rule_entry_t *entry, *entries;
+
+  if (rule == NULL)
+    return format (s, "deleted rule");
+
+  s = format (s, "[rule#%d;%U][", rule - capo_rules, format_capo_rule_action,
+	      rule->action);
+
+  /* filters */
+  vec_foreach (filter, rule->filters)
+    {
+      if (filter->type != CAPO_RULE_FILTER_NONE_TYPE)
+	s = format (s, "%U,", format_capo_rule_filter, filter);
+    }
+
+  entries = capo_rule_get_entries (rule);
+  vec_foreach (entry, entries)
+    s = format (s, "%U,", format_capo_rule_entry, entry);
+  vec_free (entries);
+  s = format (s, "]");
+
+  return (s);
+}
+
+capo_rule_t *
+capo_rule_alloc ()
+{
+  capo_rule_t *rule;
+  pool_get_zero (capo_rules, rule);
+  return rule;
+}
+
+capo_rule_t *
+capo_rule_get_if_exists (u32 index)
+{
+  if (pool_is_free_index (capo_rules, index))
+    return (NULL);
+  return pool_elt_at_index (capo_rules, index);
+}
+
+static void
+capo_rule_cleanup (capo_rule_t *rule)
+{
+  int i;
+  vec_free (rule->filters);
+  for (i = 0; i < CAPO_RULE_MAX_FLAGS; i++)
+    {
+      vec_free (rule->prefixes[i]);
+      vec_free (rule->port_ranges[i]);
+      vec_free (rule->ip_ipsets[i]);
+      vec_free (rule->ipport_ipsets[i]);
+    }
+}
+
+int
+capo_rule_update (u32 *id, capo_rule_action_t action, ip_address_family_t af,
+		  capo_rule_filter_t *filters, capo_rule_entry_t *entries)
+{
+  capo_rule_filter_t *filter;
+  capo_rule_entry_t *entry;
+  capo_rule_t *rule;
+  int rv;
+
+  rule = capo_rule_get_if_exists (*id);
+  if (rule)
+    capo_rule_cleanup (rule);
+  else
+    rule = capo_rule_alloc ();
+
+  rule->af = -1;
+  rule->action = action;
+  vec_foreach (filter, filters)
+    vec_add1 (rule->filters, *filter);
+
+  vec_foreach (entry, entries)
+    {
+      u8 flags = entry->flags;
+      switch (entry->type)
+	{
+	case CAPO_CIDR:
+	  vec_add1 (rule->prefixes[flags], entry->data.cidr);
+	  break;
+	case CAPO_PORT_RANGE:
+	  vec_add1 (rule->port_ranges[flags], entry->data.port_range);
+	  break;
+	case CAPO_PORT_IP_SET:
+	  vec_add1 (rule->ipport_ipsets[flags], entry->data.set_id);
+	  break;
+	case CAPO_IP_SET:
+	  vec_add1 (rule->ip_ipsets[flags], entry->data.set_id);
+	  break;
+	default:
+	  rv = 1;
+	  goto error;
+	}
+    }
+  *id = rule - capo_rules;
+  return 0;
+error:
+  capo_rule_cleanup (rule);
+  pool_put (capo_rules, rule);
+  return rv;
+}
+
+int
+capo_rule_delete (u32 id)
+{
+  capo_rule_t *rule;
+  rule = capo_rule_get_if_exists (id);
+  if (NULL == rule)
+    return VNET_API_ERROR_NO_SUCH_ENTRY;
+
+  capo_rule_cleanup (rule);
+  pool_put (capo_rules, rule);
+
+  return 0;
+}
+
+static clib_error_t *
+capo_rules_show_cmd_fn (vlib_main_t *vm, unformat_input_t *input,
+			vlib_cli_command_t *cmd)
+{
+  capo_rule_t *rule;
+
+  pool_foreach (rule, capo_rules)
+    {
+      vlib_cli_output (vm, "%U", format_capo_rule, rule);
+    }
+
+  return 0;
+}
+
+VLIB_CLI_COMMAND (capo_rules_show_cmd, static) = {
+  .path = "show capo rules",
+  .function = capo_rules_show_cmd_fn,
+  .short_help = "show capo rules",
+};
+
+static clib_error_t *
+capo_rules_add_cmd_fn (vlib_main_t *vm, unformat_input_t *input,
+		       vlib_cli_command_t *cmd)
+{
+  unformat_input_t _line_input, *line_input = &_line_input;
+  capo_rule_filter_t tmp_filter, *filters = 0;
+  capo_rule_entry_t tmp_entry, *entries = 0;
+  clib_error_t *error = 0;
+  capo_rule_action_t action;
+  ip_address_family_t af = AF_IP4;
+  u32 id = CAPO_INVALID_INDEX;
+  int rv;
+
+  if (!unformat_user (input, unformat_line_input, line_input))
+    return 0;
+
+  while (unformat_check_input (line_input) != UNFORMAT_END_OF_INPUT)
+    {
+      if (unformat (line_input, "update %u", &id))
+	;
+      else if (unformat_user (line_input, unformat_ip_address_family, &af))
+	;
+      else if (unformat_user (line_input, unformat_capo_rule_action, &action))
+	;
+      else if (unformat_user (line_input, unformat_capo_rule_entry,
+			      &tmp_entry))
+	vec_add1 (entries, tmp_entry);
+      else if (unformat_user (line_input, unformat_capo_rule_filter,
+			      &tmp_filter))
+	{
+	  vec_add1 (filters, tmp_filter);
+	  vlib_cli_output (vm, "%U", format_capo_rule_filter, &tmp_filter);
+	}
+      else
+	{
+	  error = clib_error_return (0, "unknown input '%U'",
+				     format_unformat_error, line_input);
+	  goto done;
+	}
+    }
+
+  rv = capo_rule_update (&id, action, af, filters, entries);
+  if (rv)
+    error = clib_error_return (0, "capo_rule_update error %d", rv);
+  else
+    vlib_cli_output (vm, "capo rule %d added", id);
+
+done:
+  vec_free (filters);
+  vec_free (entries);
+  unformat_free (line_input);
+  return error;
+}
+
+VLIB_CLI_COMMAND (capo_rules_add_cmd, static) = {
+  .path = "capo rule add",
+  .function = capo_rules_add_cmd_fn,
+  .short_help = "capo rule add [ip4|ip6] [allow|deny|log|pass]"
+		"[filter[==|!=]value]"
+		"[[src|dst][==|!=][prefix|set ID|[port-port]]]",
+  .long_help = "Add a rule, with given filters and entries\n"
+	       "filters can be `icmp-type`, `icmp-code` and `proto`",
+};
+
+static clib_error_t *
+capo_rules_del_cmd_fn (vlib_main_t *vm, unformat_input_t *input,
+		       vlib_cli_command_t *cmd)
+{
+  unformat_input_t _line_input, *line_input = &_line_input;
+  clib_error_t *error = 0;
+  u32 id = CAPO_INVALID_INDEX;
+  int rv;
+
+  if (!unformat_user (input, unformat_line_input, line_input))
+    return clib_error_return (0, "missing rule id");
+
+  while (unformat_check_input (line_input) != UNFORMAT_END_OF_INPUT)
+    {
+      if (unformat (line_input, "%u", &id))
+	;
+      else
+	{
+	  error = clib_error_return (0, "unknown input '%U'",
+				     format_unformat_error, line_input);
+	  goto done;
+	}
+    }
+
+  if (CAPO_INVALID_INDEX == id)
+    {
+      error = clib_error_return (0, "missing rule id");
+      goto done;
+    }
+
+  rv = capo_rule_delete (id);
+  if (rv)
+    error = clib_error_return (0, "capo_rule_delete errored with %d", rv);
+
+done:
+  unformat_free (line_input);
+  return error;
+}
+
+VLIB_CLI_COMMAND (capo_rules_del_cmd, static) = {
+  .path = "capo rule del",
+  .function = capo_rules_del_cmd_fn,
+  .short_help = "capo rule del [id]",
+};
+
+/*
+ * fd.io coding-style-patch-verification: ON
+ *
+ * Local Variables:
+ * eval: (c-set-style "gnu")
+ * End:
+ */
diff --git a/src/plugins/capo/capo_rule.h b/src/plugins/capo/capo_rule.h
new file mode 100644
index 000000000..0875a45c5
--- /dev/null
+++ b/src/plugins/capo/capo_rule.h
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2020 Cisco and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef included_capo_rule_h
+#define included_capo_rule_h
+
+#include <capo/capo.h>
+
+typedef vl_api_capo_rule_action_t capo_rule_action_t;
+typedef vl_api_capo_entry_type_t capo_entry_type_t;
+typedef vl_api_capo_rule_filter_type_t capo_rule_filter_type_t;
+
+typedef struct capo_rule_filter_
+{
+  capo_rule_filter_type_t type;
+  /* Content to filter against */
+  u32 value;
+  /* If true match packet.property == opaque, else packet.property != opaque */
+  u8 should_match;
+} capo_rule_filter_t;
+
+typedef union capo_entry_data_t_
+{
+  ip_prefix_t cidr;
+  capo_port_range_t port_range;
+  u32 set_id;
+} capo_entry_data_t;
+
+typedef enum capo_rule_key_flag_
+{
+  CAPO_IS_SRC = 1 << 0,
+  CAPO_IS_NOT = 1 << 1,
+  CAPO_RULE_MAX_FLAGS = 1 << 2,
+} capo_rule_key_flag_t;
+
+#define CAPO_SRC     CAPO_IS_SRC
+#define CAPO_NOT_SRC (CAPO_IS_SRC | CAPO_IS_NOT)
+#define CAPO_DST     0
+#define CAPO_NOT_DST CAPO_IS_NOT
+
+typedef struct capo_rule_entry_t_
+{
+  capo_entry_type_t type;
+  capo_entry_data_t data;
+  capo_rule_key_flag_t flags;
+} capo_rule_entry_t;
+
+typedef struct capo_rule_
+{
+  ip_address_family_t af;
+  capo_rule_action_t action;
+
+  capo_rule_filter_t *filters;
+
+  /* Indexed by capo_rule_key_flag_t */
+  ip_prefix_t *prefixes[CAPO_RULE_MAX_FLAGS];
+  u32 *ip_ipsets[CAPO_RULE_MAX_FLAGS];
+  capo_port_range_t *port_ranges[CAPO_RULE_MAX_FLAGS];
+  u32 *ipport_ipsets[CAPO_RULE_MAX_FLAGS];
+} capo_rule_t;
+
+extern capo_rule_t *capo_rules;
+
+int capo_rule_delete (u32 id);
+int capo_rule_update (u32 *id, capo_rule_action_t action,
+		      ip_address_family_t af, capo_rule_filter_t *filters,
+		      capo_rule_entry_t *entries);
+u8 *format_capo_rule (u8 *s, va_list *args);
+capo_rule_t *capo_rule_get_if_exists (u32 index);
+
+#endif
+
+/*
+ * fd.io coding-style-patch-verification: ON
+ *
+ * Local Variables:
+ * eval: (c-set-style "gnu")
+ * End:
+ */
diff --git a/src/plugins/capo/capo_test.c b/src/plugins/capo/capo_test.c
new file mode 100644
index 000000000..8bfa4ae29
--- /dev/null
+++ b/src/plugins/capo/capo_test.c
@@ -0,0 +1,490 @@
+/*
+ * Copyright (c) 2015 Cisco and/or its affiliates.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at:
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/*
+ *------------------------------------------------------------------
+ * acl_test.c - test harness plugin
+ *------------------------------------------------------------------
+ */
+
+#include <vat/vat.h>
+#include <vlibapi/api.h>
+#include <vlibmemory/api.h>
+#include <vppinfra/error.h>
+#include <vnet/ip/ip.h>
+#include <arpa/inet.h>
+
+#include <vnet/ip/ip_format_fns.h>
+#include <vnet/ethernet/ethernet_format_fns.h>
+
+#define __plugin_msg_base capo_test_main.msg_id_base
+#include <vlibapi/vat_helper_macros.h>
+
+uword unformat_sw_if_index (unformat_input_t *input, va_list *args);
+
+/* Declare message IDs */
+#include <capo/capo.api_enum.h>
+#include <capo/capo.api_types.h>
+#define vl_endianfun /* define message structures */
+#include <capo/capo.api.h>
+#undef vl_endianfun
+
+typedef struct
+{
+  /* API message ID base */
+  u16 msg_id_base;
+  vat_main_t *vat_main;
+} capo_test_main_t;
+
+capo_test_main_t capo_test_main;
+
+/* NAME: capo_get_version_reply */
+static void
+vl_api_capo_get_version_reply_t_handler (vl_api_capo_get_version_reply_t *mp)
+{
+  vat_main_t *vam = capo_test_main.vat_main;
+  clib_warning ("Calico Policy plugin version: %d.%d", ntohl (mp->major),
+		ntohl (mp->minor));
+  vam->result_ready = 1;
+}
+
+/* NAME: capo_control_ping_reply */
+static void
+vl_api_capo_control_ping_reply_t_handler (vl_api_capo_control_ping_reply_t *mp)
+{
+  vat_main_t *vam = capo_test_main.vat_main;
+  i32 retval = ntohl (mp->retval);
+  if (vam->async_mode)
+    {
+      vam->async_errors += (retval < 0);
+    }
+  else
+    {
+      vam->retval = retval;
+      vam->result_ready = 1;
+    }
+}
+
+/* NAME: ipset_create_reply */
+static void
+vl_api_capo_ipset_create_reply_t_handler (vl_api_capo_ipset_create_reply_t *mp)
+{
+  vat_main_t *vam = capo_test_main.vat_main;
+  clib_warning ("Got ipset_create_reply...");
+  vam->result_ready = 1;
+}
+
+/* NAME: rule_create_reply */
+static void
+vl_api_capo_rule_create_reply_t_handler (vl_api_capo_rule_create_reply_t *mp)
+{
+  vat_main_t *vam = capo_test_main.vat_main;
+  clib_warning ("Got rule_create_reply...");
+  vam->result_ready = 1;
+}
+
+/* NAME: policy_create_reply */
+static void
+vl_api_capo_policy_create_reply_t_handler (
+  vl_api_capo_policy_create_reply_t *mp)
+{
+  vat_main_t *vam = capo_test_main.vat_main;
+  clib_warning ("Got policy_create_reply...");
+  vam->result_ready = 1;
+}
+
+/* NAME: capo_get_version */
+
+static int
+api_capo_get_version (vat_main_t *vam)
+{
+  capo_test_main_t *cptm = &capo_test_main;
+  unformat_input_t *i = vam->input;
+  vl_api_capo_get_version_t *mp;
+  u32 msg_size = sizeof (*mp);
+  int ret;
+
+  vam->result_ready = 0;
+  mp = vl_msg_api_alloc_as_if_client (msg_size);
+  memset (mp, 0, msg_size);
+  mp->_vl_msg_id = ntohs (VL_API_CAPO_GET_VERSION + cptm->msg_id_base);
+  mp->client_index = vam->my_client_index;
+
+  /* FIXME: do something here */
+
+  while (unformat_check_input (i) != UNFORMAT_END_OF_INPUT)
+    {
+    }
+
+  /* send it... */
+  S (mp);
+
+  /* Wait for a reply... */
+  W (ret);
+  return ret;
+}
+
+/* NAME: capo_control_ping */
+
+static int
+api_capo_control_ping (vat_main_t *vam)
+{
+  capo_test_main_t *cptm = &capo_test_main;
+  unformat_input_t *i = vam->input;
+  vl_api_capo_control_ping_t *mp;
+  u32 msg_size = sizeof (*mp);
+  int ret;
+
+  vam->result_ready = 0;
+  mp = vl_msg_api_alloc_as_if_client (msg_size);
+  memset (mp, 0, msg_size);
+  mp->_vl_msg_id = ntohs (VL_API_CAPO_CONTROL_PING + cptm->msg_id_base);
+  mp->client_index = vam->my_client_index;
+
+  /* FIXME: do something here */
+
+  while (unformat_check_input (i) != UNFORMAT_END_OF_INPUT)
+    {
+    }
+
+  /* send it... */
+  S (mp);
+
+  /* Wait for a reply... */
+  W (ret);
+  return ret;
+}
+
+/* NAME: ipset_create */
+
+static int
+api_capo_ipset_create (vat_main_t *vam)
+{
+  capo_test_main_t *cptm = &capo_test_main;
+  unformat_input_t *i = vam->input;
+  vl_api_capo_ipset_create_t *mp;
+  u32 msg_size = sizeof (*mp);
+  int ret;
+
+  vam->result_ready = 0;
+  mp = vl_msg_api_alloc_as_if_client (msg_size);
+  memset (mp, 0, msg_size);
+  mp->_vl_msg_id = ntohs (VL_API_CAPO_IPSET_CREATE + cptm->msg_id_base);
+  mp->client_index = vam->my_client_index;
+
+  /* FIXME: do something here */
+
+  while (unformat_check_input (i) != UNFORMAT_END_OF_INPUT)
+    {
+    }
+
+  /* send it... */
+  S (mp);
+
+  /* Wait for a reply... */
+  W (ret);
+  return ret;
+}
+
+/* NAME: ipset_add_del_members */
+
+static int
+api_capo_ipset_add_del_members (vat_main_t *vam)
+{
+  capo_test_main_t *cptm = &capo_test_main;
+  unformat_input_t *i = vam->input;
+  vl_api_capo_ipset_add_del_members_t *mp;
+  u32 msg_size = sizeof (*mp);
+  int ret;
+
+  vam->result_ready = 0;
+  mp = vl_msg_api_alloc_as_if_client (msg_size);
+  memset (mp, 0, msg_size);
+  mp->_vl_msg_id =
+    ntohs (VL_API_CAPO_IPSET_ADD_DEL_MEMBERS + cptm->msg_id_base);
+  mp->client_index = vam->my_client_index;
+
+  /* FIXME: do something here */
+
+  while (unformat_check_input (i) != UNFORMAT_END_OF_INPUT)
+    {
+    }
+
+  /* send it... */
+  S (mp);
+
+  /* Wait for a reply... */
+  W (ret);
+  return ret;
+}
+
+/* NAME: ipset_delete */
+
+static int
+api_capo_ipset_delete (vat_main_t *vam)
+{
+  capo_test_main_t *cptm = &capo_test_main;
+  unformat_input_t *i = vam->input;
+  vl_api_capo_ipset_delete_t *mp;
+  u32 msg_size = sizeof (*mp);
+  int ret;
+
+  vam->result_ready = 0;
+  mp = vl_msg_api_alloc_as_if_client (msg_size);
+  memset (mp, 0, msg_size);
+  mp->_vl_msg_id = ntohs (VL_API_CAPO_IPSET_DELETE + cptm->msg_id_base);
+  mp->client_index = vam->my_client_index;
+
+  /* FIXME: do something here */
+
+  while (unformat_check_input (i) != UNFORMAT_END_OF_INPUT)
+    {
+    }
+
+  /* send it... */
+  S (mp);
+
+  /* Wait for a reply... */
+  W (ret);
+  return ret;
+}
+
+/* NAME: rule_create */
+
+static int
+api_capo_rule_create (vat_main_t *vam)
+{
+  capo_test_main_t *cptm = &capo_test_main;
+  unformat_input_t *i = vam->input;
+  vl_api_capo_rule_create_t *mp;
+  u32 msg_size = sizeof (*mp);
+  int ret;
+
+  vam->result_ready = 0;
+  mp = vl_msg_api_alloc_as_if_client (msg_size);
+  memset (mp, 0, msg_size);
+  mp->_vl_msg_id = ntohs (VL_API_CAPO_RULE_CREATE + cptm->msg_id_base);
+  mp->client_index = vam->my_client_index;
+
+  /* FIXME: do something here */
+
+  while (unformat_check_input (i) != UNFORMAT_END_OF_INPUT)
+    {
+    }
+
+  /* send it... */
+  S (mp);
+
+  /* Wait for a reply... */
+  W (ret);
+  return ret;
+}
+
+/* NAME: rule_update */
+
+static int
+api_capo_rule_update (vat_main_t *vam)
+{
+  capo_test_main_t *cptm = &capo_test_main;
+  unformat_input_t *i = vam->input;
+  vl_api_capo_rule_update_t *mp;
+  u32 msg_size = sizeof (*mp);
+  int ret;
+
+  vam->result_ready = 0;
+  mp = vl_msg_api_alloc_as_if_client (msg_size);
+  memset (mp, 0, msg_size);
+  mp->_vl_msg_id = ntohs (VL_API_CAPO_RULE_UPDATE + cptm->msg_id_base);
+  mp->client_index = vam->my_client_index;
+
+  /* FIXME: do something here */
+
+  while (unformat_check_input (i) != UNFORMAT_END_OF_INPUT)
+    {
+    }
+
+  /* send it... */
+  S (mp);
+
+  /* Wait for a reply... */
+  W (ret);
+  return ret;
+}
+
+/* NAME: rule_delete */
+
+static int
+api_capo_rule_delete (vat_main_t *vam)
+{
+  capo_test_main_t *cptm = &capo_test_main;
+  unformat_input_t *i = vam->input;
+  vl_api_capo_rule_delete_t *mp;
+  u32 msg_size = sizeof (*mp);
+  int ret;
+
+  vam->result_ready = 0;
+  mp = vl_msg_api_alloc_as_if_client (msg_size);
+  memset (mp, 0, msg_size);
+  mp->_vl_msg_id = ntohs (VL_API_CAPO_RULE_DELETE + cptm->msg_id_base);
+  mp->client_index = vam->my_client_index;
+
+  /* FIXME: do something here */
+
+  while (unformat_check_input (i) != UNFORMAT_END_OF_INPUT)
+    {
+    }
+
+  /* send it... */
+  S (mp);
+
+  /* Wait for a reply... */
+  W (ret);
+  return ret;
+}
+
+/* NAME: policy_create */
+
+static int
+api_capo_policy_create (vat_main_t *vam)
+{
+  capo_test_main_t *cptm = &capo_test_main;
+  unformat_input_t *i = vam->input;
+  vl_api_capo_policy_create_t *mp;
+  u32 msg_size = sizeof (*mp);
+  int ret;
+
+  vam->result_ready = 0;
+  mp = vl_msg_api_alloc_as_if_client (msg_size);
+  memset (mp, 0, msg_size);
+  mp->_vl_msg_id = ntohs (VL_API_CAPO_POLICY_CREATE + cptm->msg_id_base);
+  mp->client_index = vam->my_client_index;
+
+  /* FIXME: do something here */
+
+  while (unformat_check_input (i) != UNFORMAT_END_OF_INPUT)
+    {
+    }
+
+  /* send it... */
+  S (mp);
+
+  /* Wait for a reply... */
+  W (ret);
+  return ret;
+}
+
+/* NAME: policy_update */
+
+static int
+api_capo_policy_update (vat_main_t *vam)
+{
+  capo_test_main_t *cptm = &capo_test_main;
+  unformat_input_t *i = vam->input;
+  vl_api_capo_policy_update_t *mp;
+  u32 msg_size = sizeof (*mp);
+  int ret;
+
+  vam->result_ready = 0;
+  mp = vl_msg_api_alloc_as_if_client (msg_size);
+  memset (mp, 0, msg_size);
+  mp->_vl_msg_id = ntohs (VL_API_CAPO_POLICY_UPDATE + cptm->msg_id_base);
+  mp->client_index = vam->my_client_index;
+
+  /* FIXME: do something here */
+
+  while (unformat_check_input (i) != UNFORMAT_END_OF_INPUT)
+    {
+    }
+
+  /* send it... */
+  S (mp);
+
+  /* Wait for a reply... */
+  W (ret);
+  return ret;
+}
+
+/* NAME: policy_delete */
+
+static int
+api_capo_policy_delete (vat_main_t *vam)
+{
+  capo_test_main_t *cptm = &capo_test_main;
+  unformat_input_t *i = vam->input;
+  vl_api_capo_policy_delete_t *mp;
+  u32 msg_size = sizeof (*mp);
+  int ret;
+
+  vam->result_ready = 0;
+  mp = vl_msg_api_alloc_as_if_client (msg_size);
+  memset (mp, 0, msg_size);
+  mp->_vl_msg_id = ntohs (VL_API_CAPO_POLICY_DELETE + cptm->msg_id_base);
+  mp->client_index = vam->my_client_index;
+
+  /* FIXME: do something here */
+
+  while (unformat_check_input (i) != UNFORMAT_END_OF_INPUT)
+    {
+    }
+
+  /* send it... */
+  S (mp);
+
+  /* Wait for a reply... */
+  W (ret);
+  return ret;
+}
+
+/* NAME: configure_policies */
+
+static int
+api_capo_configure_policies (vat_main_t *vam)
+{
+  capo_test_main_t *cptm = &capo_test_main;
+  unformat_input_t *i = vam->input;
+  vl_api_capo_configure_policies_t *mp;
+  u32 msg_size = sizeof (*mp);
+  int ret;
+
+  vam->result_ready = 0;
+  mp = vl_msg_api_alloc_as_if_client (msg_size);
+  memset (mp, 0, msg_size);
+  mp->_vl_msg_id = ntohs (VL_API_CAPO_CONFIGURE_POLICIES + cptm->msg_id_base);
+  mp->client_index = vam->my_client_index;
+
+  /* FIXME: do something here */
+
+  while (unformat_check_input (i) != UNFORMAT_END_OF_INPUT)
+    {
+    }
+
+  /* send it... */
+  S (mp);
+
+  /* Wait for a reply... */
+  W (ret);
+  return ret;
+}
+
+#define VL_API_LOCAL_SETUP_MESSAGE_ID_TABLE local_setup_message_id_table
+static void
+local_setup_message_id_table (vat_main_t *vam)
+{
+  // hash_set_mem (vam->function_by_name, "acl_add_replace_from_file",
+  // api_capo_acl_add_replace_from_file); hash_set_mem (vam->help_by_name,
+  // "acl_add_replace_from_file", "filename <file> [permit]
+  // [append-default-permit]");
+}
+
+#include <capo/capo.api_test.c>
diff --git a/src/plugins/capo/test/test_capo.py b/src/plugins/capo/test/test_capo.py
new file mode 100644
index 000000000..dec9c56f7
--- /dev/null
+++ b/src/plugins/capo/test/test_capo.py
@@ -0,0 +1,806 @@
+#!/usr/bin/env python3
+
+import random
+import unittest
+from ipaddress import (IPv4Address, IPv4Network, IPv6Address, IPv6Network,
+                       ip_address, ip_network)
+from itertools import product
+
+from framework import VppTestCase, VppTestRunner
+from scapy.layers.inet import (ICMP, IP, TCP, UDP, ICMPerror, IPerror,
+                               TCPerror, UDPerror)
+from scapy.layers.inet6 import (ICMPv6DestUnreach, ICMPv6EchoReply,
+                                ICMPv6EchoRequest, IPerror6, IPv6)
+from scapy.layers.l2 import Ether
+from scapy.packet import Raw
+from vpp_ip import INVALID_INDEX, DpoProto
+from vpp_object import VppObject
+from vpp_papi import VppEnum
+
+icmp4_type = 8  # echo request
+icmp4_code = 3
+icmp6_type = 128  # echo request
+icmp6_code = 3
+tcp_protocol = 6
+icmp_protocol = 1
+icmp6_protocol = 58
+udp_protocol = 17
+src_l4 = 1234
+dst_l4 = 4321
+
+
+def random_payload():
+    return Raw(load=bytearray(random.getrandbits(8) for _ in range(20)))
+
+
+class VppCapoPolicyItem():
+    def __init__(self, is_inbound, rule_id):
+        self._is_inbound = is_inbound
+        self._rule_id = rule_id
+
+    def encode(self):
+        return {'rule_id': self._rule_id, 'is_inbound': self._is_inbound}
+
+
+class VppCapoPolicy(VppObject):
+    def __init__(self, test, rules):
+        self._test = test
+        self._rules = rules
+        self.encoded_rules = []
+        self.init_rules()
+
+    def init_rules(self):
+        self.encoded_rules = []
+        for rule in self._rules:
+            self.encoded_rules.append(rule.encode())
+
+    def add_vpp_config(self):
+        r = self._test.vapi.capo_policy_create(
+            len(self.encoded_rules),
+            self.encoded_rules)
+        self._test.assertEqual(0, r.retval)
+        self._test.registry.register(self, self._test.logger)
+        self._test.logger.info("capo_policy_create retval=" + str(r.retval))
+        self._policy_id = r.policy_id
+        self._test.logger.info(self._test.vapi.cli("show capo policies verbose"))
+
+    def capo_policy_update(self, rules):
+        self._rules = rules
+        self.init_rules()
+        r = self._test.vapi.capo_policy_update(
+            self._policy_id,
+            len(self.encoded_rules),
+            self.encoded_rules)
+        self._test.assertEqual(0, r.retval)
+
+    def capo_policy_delete(self):
+        r = self._test.vapi.capo_policy_delete(self._policy_id)
+        self._test.assertEqual(0, r.retval)
+        self._test.logger.info(self._test.vapi.cli("show capo policies"))
+
+    def remove_vpp_config(self):
+        self.capo_policy_delete()
+
+    def query_vpp_config(self):
+        self._test.logger.info("query vpp config")
+        self._test.logger.info(self._test.vapi.cli("show capo policies verbose"))
+
+
+class VppCapoFilter:
+    def __init__(self, type=None, value=0, should_match=0):
+        self._filter_type = type if type != None else FILTER_TYPE_NONE
+        self._filter_value = value
+        self._should_match = should_match
+
+    def encode(self):
+        return {'type': self._filter_type,
+            'value': self._filter_value,
+            'should_match': self._should_match}
+
+
+class VppCapoRule(VppObject):
+    def __init__(self, test, is_v6, action, filters=[], matches=[]):
+        self._test = test
+        # This is actually unused
+        self._af = 255
+        self.init_rule(action, filters, matches)
+
+    def vpp_id(self):
+        return self._rule_id
+
+    def init_rule(self, action, filters=[], matches=[]):
+        self._action = action
+        self._filters = filters
+        self._matches = matches
+        self.encoded_filters = []
+        for filter in self._filters:
+            self.encoded_filters.append(filter.encode())
+        while len(self.encoded_filters) < 3:
+            self.encoded_filters.append(VppCapoFilter().encode())
+        self._test.assertEqual(len(self.encoded_filters), 3)
+
+    def add_vpp_config(self):
+        r = self._test.vapi.capo_rule_create(
+            {'af': self._af,
+             'action': self._action,
+             'filters': self.encoded_filters,
+             'num_entries': len(self._matches),
+             'matches': self._matches
+            })
+        self._test.assertEqual(0, r.retval)
+        self._test.registry.register(self, self._test.logger)
+        self._test.logger.info("capo_rule_create retval=" + str(r.retval))
+        self._rule_id = r.rule_id
+        self._test.logger.info("rules id : " + str(self._rule_id))
+        self._test.logger.info(self._test.vapi.cli("show capo rules"))
+
+    def capo_rule_update(self, filters, matches):
+        self.init_rule(self._action, filters, matches)
+        r = self._test.vapi.capo_rule_update(
+            self._rule_id,
+            {'af': self._af,
+             'action': self._action,
+             'filters': self.encoded_filters,
+             'num_entries': len(self._matches),
+             'matches': self._matches
+            })
+        self._test.assertEqual(0, r.retval)
+        self._test.registry.register(self, self._test.logger)
+        self._test.logger.info("capo rule update")
+        self._test.logger.info(self._test.vapi.cli("show capo rules"))
+
+    def capo_rule_delete(self):
+        r = self._test.vapi.capo_rule_delete(self._rule_id)
+        self._test.assertEqual(0, r.retval)
+        self._test.logger.info(self._test.vapi.cli("show capo rules"))
+
+    def remove_vpp_config(self):
+        self.capo_rule_delete()
+
+    def query_vpp_config(self):
+        self._test.logger.info("query vpp config")
+        self._test.logger.info(self._test.vapi.cli("show capo rules"))
+
+
+class VppCapoIpset(VppObject):
+    def __init__(self, test, type, members):
+        self.test = test
+        self.type = type
+        self.members = members
+
+    def add_vpp_config(self):
+        r = self.test.vapi.capo_ipset_create(self.type)
+        self.test.assertEqual(0, r.retval)
+        self.vpp_id = r.set_id
+        encoded_members = []
+        for m in self.members:
+            if self.type == IPSET_TYPE_IP:
+                encoded_members.append({"val":{"address": m}})
+            elif self.type == IPSET_TYPE_IP_PORT:
+                encoded_members.append({"val":{"tuple": m}})
+            elif self.type == IPSET_TYPE_NET:
+                encoded_members.append({"val":{"prefix": m}})
+        r = self.test.vapi.capo_ipset_add_del_members(
+            set_id=self.vpp_id,
+            is_add=True,
+            len=len(encoded_members),
+            members=encoded_members,
+        )
+        self.test.assertEqual(0, r.retval)
+
+    def query_vpp_config(self):
+        pass
+
+    def remove_vpp_config(self):
+        r = self.test.vapi.capo_ipset_delete(set_id=self.vpp_id)
+        self.test.assertEqual(0, r.retval)
+
+
+
+class BaseCapoTest(VppTestCase):
+    @classmethod
+    def setUpClass(self):
+        super(BaseCapoTest, self).setUpClass()
+        # We can't define these before the API is loaded, so here they are...
+        global ACTION_ALLOW, ACTION_DENY, ACTION_PASS, ACTION_LOG
+        ACTION_ALLOW = VppEnum.vl_api_capo_rule_action_t.CAPO_ALLOW
+        ACTION_DENY = VppEnum.vl_api_capo_rule_action_t.CAPO_DENY
+        ACTION_PASS = VppEnum.vl_api_capo_rule_action_t.CAPO_PASS
+        ACTION_LOG = VppEnum.vl_api_capo_rule_action_t.CAPO_LOG
+        global FILTER_TYPE_NONE, FILTER_TYPE_L4_PROTO, FILTER_TYPE_ICMP_CODE, FILTER_TYPE_ICMP_TYPE
+        FILTER_TYPE_NONE = VppEnum.vl_api_capo_rule_filter_type_t.CAPO_RULE_FILTER_NONE_TYPE
+        FILTER_TYPE_L4_PROTO = VppEnum.vl_api_capo_rule_filter_type_t.CAPO_RULE_FILTER_L4_PROTO
+        FILTER_TYPE_ICMP_CODE = VppEnum.vl_api_capo_rule_filter_type_t.CAPO_RULE_FILTER_ICMP_CODE
+        FILTER_TYPE_ICMP_TYPE = VppEnum.vl_api_capo_rule_filter_type_t.CAPO_RULE_FILTER_ICMP_TYPE
+        global ENTRY_CIDR, ENTRY_PORT_RANGE, ENTRY_PORT_IP_SET, ENTRY_IP_SET
+        ENTRY_CIDR = VppEnum.vl_api_capo_entry_type_t.CAPO_CIDR
+        ENTRY_PORT_RANGE = VppEnum.vl_api_capo_entry_type_t.CAPO_PORT_RANGE
+        ENTRY_PORT_IP_SET = VppEnum.vl_api_capo_entry_type_t.CAPO_PORT_IP_SET
+        ENTRY_IP_SET = VppEnum.vl_api_capo_entry_type_t.CAPO_IP_SET
+        global IPSET_TYPE_IP, IPSET_TYPE_IP_PORT, IPSET_TYPE_NET
+        IPSET_TYPE_IP = VppEnum.vl_api_capo_ipset_type_t.CAPO_IP
+        IPSET_TYPE_IP_PORT = VppEnum.vl_api_capo_ipset_type_t.CAPO_IP_AND_PORT
+        IPSET_TYPE_NET = VppEnum.vl_api_capo_ipset_type_t.CAPO_NET
+
+        self.create_pg_interfaces(range(2))
+        for i in self.pg_interfaces:
+            i.admin_up()
+            # Add one additional neighbor on each side for tests with different addresses
+            i.generate_remote_hosts(2)
+            i.config_ip4()
+            i.configure_ipv4_neighbors()
+            i.config_ip6()
+            i.configure_ipv6_neighbors()
+
+    @classmethod
+    def tearDownClass(self):
+        for i in self.pg_interfaces:
+            i.unconfig_ip4()
+            i.unconfig_ip6()
+            i.admin_down()
+        super(BaseCapoTest, self).tearDownClass()
+
+
+    def setUp(self):
+        super(BaseCapoTest, self).setUp()
+
+    def tearDown(self):
+        super(BaseCapoTest, self).tearDown()
+
+    def configure_policies(self, interface, ingress, egress, profiles):
+        id_list = []
+        for policy in ingress + egress + profiles:
+            id_list.append(policy._policy_id)
+
+        r = self.vapi.capo_configure_policies(
+             interface.sw_if_index,
+             len(ingress),
+             len(egress),
+             len(ingress) + len(egress) + len(profiles),
+             id_list)
+        self.assertEqual(0, r.retval)
+
+    def base_ip_packet(self, is_v6=False, second_src_ip=False, second_dst_ip=False):
+        IP46 = IPv6 if is_v6 else IP
+        src_host = self.pg0.remote_hosts[1 if second_src_ip else 0]
+        dst_host = self.pg1.remote_hosts[1 if second_dst_ip else 0]
+        src_addr = src_host.ip6 if is_v6 else src_host.ip4
+        dst_addr = dst_host.ip6 if is_v6 else dst_host.ip4
+        return Ether(src=src_host.mac, dst=self.pg0.local_mac) / IP46(src=src_addr,
+                dst=dst_addr)
+
+    def do_test_one_rule(self, filters, matches, matching_packets, not_matching_packets):
+        # Caution: because of how vpp works, packets may be reordered (v4 first, v6 next)
+        # which may break the check on received packets
+        # Therefore, in matching packets, all v4 packets must be before all v6 packets
+        self.rule.capo_rule_update(filters, matches)
+        self.send_test_packets(self.pg0, self.pg1, matching_packets, not_matching_packets)
+
+    def send_test_packets(self, from_if, to_if, passing_packets, dropped_packets):
+        if len(passing_packets) > 0:
+            rxl = self.send_and_expect(from_if, passing_packets, to_if)
+            self.assertEqual(len(rxl), len(passing_packets))
+            for i in range(len(passing_packets)):
+                rx = rxl[i].payload
+                tx = passing_packets[i].payload
+                tx = tx.__class__(bytes(tx)) # Compute all fields
+                # Remove IP[v6] TTL / checksum that are changed on forwarding
+                if IP in tx:
+                    del tx.chksum, tx.ttl, rx.chksum, rx.ttl
+                elif IPv6 in tx:
+                    del tx.hlim, rx.hlim
+                self.assertEqual(rx, tx)
+        if len(dropped_packets) > 0:
+            self.send_and_assert_no_replies(from_if, dropped_packets, to_if, timeout=0.1)
+        self.vapi.cli("clear acl-plugin sessions")
+
+
+class TestCapoMatches(BaseCapoTest):
+    """ Calico Policies rule matching tests  """
+    @classmethod
+    def setUpClass(self):
+        super(TestCapoMatches, self).setUpClass()
+
+    @classmethod
+    def tearDownClass(self):
+        super(TestCapoMatches, self).tearDownClass()
+
+    def setUp(self):
+        super(TestCapoMatches, self).setUp()
+        self.rule = VppCapoRule(self, is_v6=False, action=ACTION_ALLOW)
+        self.rule.add_vpp_config()
+        self.policy = VppCapoPolicy(self, [VppCapoPolicyItem(is_inbound=1, rule_id=self.rule.vpp_id())])
+        self.policy.add_vpp_config()
+        self.configure_policies(self.pg1, [self.policy], [], [])
+        self.src_ip_ipset = VppCapoIpset(self, IPSET_TYPE_IP, [self.pg0.remote_ip4, self.pg0.remote_ip6])
+        self.src_ip_ipset.add_vpp_config()
+        self.dst_ip_ipset = VppCapoIpset(self, IPSET_TYPE_IP, [self.pg1.remote_ip4, self.pg1.remote_ip6])
+        self.dst_ip_ipset.add_vpp_config()
+        self.src_net_ipset = VppCapoIpset(self, IPSET_TYPE_NET, [self.pg0.remote_ip4+"/32", self.pg0.remote_ip6+"/128"])
+        self.src_net_ipset.add_vpp_config()
+        self.dst_net_ipset = VppCapoIpset(self, IPSET_TYPE_NET, [self.pg1.remote_ip4+"/32", self.pg1.remote_ip6+"/128"])
+        self.dst_net_ipset.add_vpp_config()
+        self.src_ipport_ipset = VppCapoIpset(self, IPSET_TYPE_IP_PORT, [
+            {"address":self.pg0.remote_ip4, "l4_proto": tcp_protocol, "port": src_l4},
+            {"address":self.pg0.remote_ip6, "l4_proto": tcp_protocol, "port": src_l4}
+        ])
+        self.src_ipport_ipset.add_vpp_config()
+        self.dst_ipport_ipset = VppCapoIpset(self, IPSET_TYPE_IP_PORT, [
+            {"address":self.pg1.remote_ip4, "l4_proto": tcp_protocol, "port": dst_l4},
+            {"address":self.pg1.remote_ip6, "l4_proto": tcp_protocol, "port": dst_l4}
+        ])
+        self.dst_ipport_ipset.add_vpp_config()
+
+    def tearDown(self):
+        self.vapi.cli("clear acl-plugin sessions")
+        self.configure_policies(self.pg1, [], [], [])
+        self.policy.capo_policy_delete()
+        self.rule.capo_rule_delete()
+        super(TestCapoMatches, self).tearDown()
+
+    def test_empty_rule(self):
+        # Empty rule matches everything
+        valid = [
+            self.base_ip_packet(False) / TCP(sport=src_l4, dport=dst_l4) / random_payload(),
+            self.base_ip_packet(False) / UDP(sport=src_l4, dport=dst_l4) / random_payload(),
+            self.base_ip_packet(False) / ICMP(type=icmp4_type, code=icmp4_code) / random_payload(),
+            self.base_ip_packet(True) / TCP(sport=src_l4, dport=dst_l4) / random_payload(),
+            self.base_ip_packet(True) / UDP(sport=src_l4, dport=dst_l4) / random_payload(),
+            self.base_ip_packet(True) / ICMPv6EchoRequest(type=icmp6_type, code=icmp6_code) / random_payload(),
+        ]
+        self.do_test_one_rule([], [], valid, [])
+
+    def capo_test_icmp(self, is_v6):
+        ICMP46 = ICMPv6EchoRequest if is_v6 else ICMP
+        icmp_type = icmp6_type if is_v6 else icmp4_type
+        icmp_code = icmp6_code if is_v6 else icmp4_code
+
+        # Define filter on ICMP type
+        filters = [VppCapoFilter(FILTER_TYPE_ICMP_TYPE, value=icmp_type, should_match=1)]
+        valid = self.base_ip_packet(is_v6) / ICMP46(type=icmp_type, code=icmp_code) / random_payload()
+        invalid = self.base_ip_packet(is_v6) / ICMP46(type=11, code=22) / random_payload()
+        self.do_test_one_rule(filters, [], [valid], [invalid])
+
+        # Define filter on ICMP type  / should match = 0
+        filters = [VppCapoFilter(FILTER_TYPE_ICMP_TYPE, value=11, should_match=0)]
+        invalid = self.base_ip_packet(is_v6) / ICMP46(type=11, code=icmp_code) / random_payload()
+        valid = self.base_ip_packet(is_v6) / ICMP46(type=icmp_type, code=icmp_code) / random_payload()
+        self.do_test_one_rule(filters, [], [valid], [invalid])
+
+    def test_icmp4_type(self):
+        self.capo_test_icmp(is_v6=False)
+
+    def test_icmp6_type(self):
+        self.capo_test_icmp(is_v6=True)
+
+    def capo_test_icmp_code(self, is_v6):
+        ICMP46 = ICMPv6EchoRequest if is_v6 else ICMP
+        icmp_type = 1 if is_v6 else 3   # Destination unreachable
+        icmp_code = 9 # admin prohibited
+
+        # Define filter on ICMP type
+        filters = [VppCapoFilter(FILTER_TYPE_ICMP_CODE, value=icmp_code, should_match=1)]
+        valid = self.base_ip_packet(is_v6) / ICMP46(type=icmp_type, code=icmp_code) / random_payload()
+        invalid = self.base_ip_packet(is_v6) / ICMP46(type=icmp_type, code=icmp_code-1) / random_payload()
+        self.do_test_one_rule(filters, [], [valid], [invalid])
+
+        # Define filter on ICMP type  / should match = 0
+        filters = [VppCapoFilter(FILTER_TYPE_ICMP_CODE, value=icmp_code, should_match=0)]
+        valid = self.base_ip_packet(is_v6) / ICMP46(type=icmp_type, code=icmp_code+1) / random_payload()
+        invalid = self.base_ip_packet(is_v6) / ICMP46(type=icmp_type, code=icmp_code) / random_payload()
+        self.do_test_one_rule(filters, [], [valid], [invalid])
+
+    def test_icmp4_code(self):
+        self.capo_test_icmp(is_v6=False)
+
+    def test_icmp6_code(self):
+        self.capo_test_icmp(is_v6=True)
+
+    def capo_test_l4proto(self, is_v6, l4proto):
+        filter_value = 0
+        if l4proto == TCP:
+            filter_value = tcp_protocol
+        elif l4proto == UDP:
+            filter_value = udp_protocol
+
+        # Define filter on l4proto type
+        filters = [VppCapoFilter(FILTER_TYPE_L4_PROTO, value=filter_value, should_match=1)]
+
+        # Send tcp pg0 -> pg1
+        valid = self.base_ip_packet(is_v6) / l4proto(sport=src_l4, dport=dst_l4) / random_payload()
+        # send icmp packet (different l4proto) and expect packet is filtered
+        invalid = self.base_ip_packet(is_v6) / ICMP(type=8, code=3) / random_payload()
+        self.do_test_one_rule(filters, [], [valid], [invalid])
+
+        # Define filter on l4proto / should match = 0
+        filters = [VppCapoFilter(FILTER_TYPE_L4_PROTO, value=filter_value, should_match=0)]
+        # send l4proto packet and expect it is filtered
+        invalid = self.base_ip_packet(is_v6) / l4proto(sport=src_l4, dport=dst_l4) / random_payload()
+        # send icmp packet (different l4proto) and expect it is not filtered
+        valid = self.base_ip_packet(is_v6) / ICMP(type=8, code=3) / random_payload()
+        self.do_test_one_rule(filters, [], [valid], [invalid])
+
+    def test_l4proto_tcp4(self):
+        self.capo_test_l4proto(False, TCP)
+
+    def test_l4proto_tcp6(self):
+        self.capo_test_l4proto(True, TCP)
+
+    def test_l4proto_udp4(self):
+        self.capo_test_l4proto(False, UDP)
+
+    def test_l4proto_udp6(self):
+        self.capo_test_l4proto(True, UDP)
+
+    def test_prefixes_ip6(self):
+        self.test_prefixes(True)
+
+    def test_prefixes(self, is_ip6=False):
+        pload = lambda : TCP(sport=src_l4, dport=dst_l4) / random_payload()
+        dst_ip_match = self.pg1.remote_ip6 + "/128" if is_ip6 else self.pg1.remote_ip4 + "/32"
+        match = {"is_src": False, "is_not": False, "type": ENTRY_CIDR, "data": {"cidr": dst_ip_match}}
+        valid = self.base_ip_packet(is_ip6) / pload()
+        invalid = self.base_ip_packet(is_ip6, second_dst_ip=True) / pload()
+        self.do_test_one_rule([], [match], [valid], [invalid])
+
+        match['is_not'] = True
+        self.do_test_one_rule([], [match], [invalid], [valid])
+
+        src_ip_match = self.pg0.remote_ip6 + "/128" if is_ip6 else self.pg0.remote_ip4 + "/32"
+        match = {"is_src": True, "is_not": False, "type": ENTRY_CIDR, "data": {"cidr": src_ip_match}}
+        valid = self.base_ip_packet(is_ip6) / pload()
+        invalid = self.base_ip_packet(is_ip6, second_src_ip=True) / pload()
+        self.do_test_one_rule([], [match], [valid], [invalid])
+
+        match['is_not'] = True
+        self.do_test_one_rule([], [match], [invalid], [valid])
+
+    def test_port_ranges_ip6(self):
+        self.test_prefixes(True)
+
+    def test_port_ranges(self, is_ip6=False):
+        base = self.base_ip_packet(is_ip6)
+        test_port = 5123
+        # Test all match kinds
+        match = {"is_src": False, "is_not": False, "type": ENTRY_PORT_RANGE,
+                 "data": {"port_range": {"start": test_port, "end": test_port}}}
+        valid = base / TCP(sport=test_port, dport=test_port) / random_payload()
+        invalid = [
+            base / TCP(sport=test_port, dport=test_port+1) / random_payload(),
+            base / TCP(sport=test_port, dport=test_port-1) / random_payload(),
+        ]
+        self.do_test_one_rule([], [match], [valid], invalid)
+
+        match['is_not'] = True
+        self.do_test_one_rule([], [match], invalid, [valid])
+
+        match = {"is_src": True, "is_not": False, "type": ENTRY_PORT_RANGE,
+                 "data": {"port_range": {"start": test_port, "end": test_port}}}
+        valid = base / TCP(sport=test_port, dport=test_port) / random_payload()
+        invalid = [
+            base / TCP(sport=test_port+1, dport=test_port) / random_payload(),
+            base / TCP(sport=test_port-1, dport=test_port) / random_payload(),
+        ]
+        self.do_test_one_rule([], [match], [valid], invalid)
+
+        match['is_not'] = True
+        self.do_test_one_rule([], [match], invalid, [valid])
+
+        # Test port ranges with several ports & UDP
+        match = {"is_src": False, "is_not": False, "type": ENTRY_PORT_RANGE,
+                 "data": {"port_range": {"start": test_port, "end": test_port+10}}}
+        valid = [
+            base / TCP(sport=test_port, dport=test_port) / random_payload(),
+            base / TCP(sport=test_port, dport=test_port+5) / random_payload(),
+            base / TCP(sport=test_port, dport=test_port+10) / random_payload(),
+            base / UDP(sport=test_port, dport=test_port) / random_payload(),
+            base / UDP(sport=test_port, dport=test_port+5) / random_payload(),
+            base / UDP(sport=test_port, dport=test_port+10) / random_payload(),
+        ]
+        invalid = [
+            base / TCP(sport=test_port, dport=test_port-1) / random_payload(),
+            base / TCP(sport=test_port, dport=test_port+11) / random_payload(),
+        ]
+        self.do_test_one_rule([], [match], valid, invalid)
+
+
+    def test_ip_ipset_ip6(self):
+        self.test_ip_ipset(True)
+
+    def test_ip_ipset(self, is_ip6=False):
+        pload = lambda : TCP(sport=src_l4, dport=dst_l4) / random_payload()
+        dst_ip_match = self.pg1.remote_ip6 + "/128" if is_ip6 else self.pg1.remote_ip4 + "/32"
+        match = {"is_src": False, "is_not": False, "type": ENTRY_IP_SET,
+                 "data": {"set_id": {"set_id": self.dst_ip_ipset.vpp_id}}}
+        valid = self.base_ip_packet(is_ip6) / pload()
+        invalid = self.base_ip_packet(is_ip6, second_dst_ip=True) / pload()
+        self.do_test_one_rule([], [match], [valid], [invalid])
+
+        match['is_not'] = True
+        self.do_test_one_rule([], [match], [invalid], [valid])
+
+        src_ip_match = self.pg0.remote_ip6 + "/128" if is_ip6 else self.pg0.remote_ip4 + "/32"
+        match = {"is_src": True, "is_not": False, "type": ENTRY_IP_SET,
+                 "data": {"set_id": {"set_id": self.src_ip_ipset.vpp_id}}}
+        valid = self.base_ip_packet(is_ip6) / pload()
+        invalid = self.base_ip_packet(is_ip6, second_src_ip=True) / pload()
+        self.do_test_one_rule([], [match], [valid], [invalid])
+
+        match['is_not'] = True
+        self.do_test_one_rule([], [match], [invalid], [valid])
+
+    def test_net_ipset_ip6(self):
+        self.test_net_ipset(True)
+
+    def test_net_ipset(self, is_ip6=False):
+        pload = lambda : TCP(sport=src_l4, dport=dst_l4) / random_payload()
+        dst_ip_match = self.pg1.remote_ip6 + "/128" if is_ip6 else self.pg1.remote_ip4 + "/32"
+        match = {"is_src": False, "is_not": False, "type": ENTRY_IP_SET,
+                 "data": {"set_id": {"set_id": self.dst_net_ipset.vpp_id}}}
+        valid = self.base_ip_packet(is_ip6) / pload()
+        invalid = self.base_ip_packet(is_ip6, second_dst_ip=True) / pload()
+        self.do_test_one_rule([], [match], [valid], [invalid])
+
+        match['is_not'] = True
+        self.do_test_one_rule([], [match], [invalid], [valid])
+
+        src_ip_match = self.pg0.remote_ip6 + "/128" if is_ip6 else self.pg0.remote_ip4 + "/32"
+        match = {"is_src": True, "is_not": False, "type": ENTRY_IP_SET,
+                 "data": {"set_id": {"set_id": self.src_net_ipset.vpp_id}}}
+        valid = self.base_ip_packet(is_ip6) / pload()
+        invalid = self.base_ip_packet(is_ip6, second_src_ip=True) / pload()
+        self.do_test_one_rule([], [match], [valid], [invalid])
+
+        match['is_not'] = True
+        self.do_test_one_rule([], [match], [invalid], [valid])
+
+    def test_ipport_ipset_ip6(self):
+        self.test_ipport_ipset(True)
+
+    def test_ipport_ipset(self, is_ip6=False):
+        match = {"is_src": False, "is_not": False, "type": ENTRY_PORT_IP_SET,
+                 "data": {"set_id": {"set_id": self.dst_ipport_ipset.vpp_id}}}
+        valid = self.base_ip_packet(is_ip6) / TCP(sport=src_l4, dport=dst_l4) / random_payload()
+        invalid = [ # Change all criteria: address, proto, port
+            self.base_ip_packet(is_ip6, second_dst_ip=True) / TCP(sport=src_l4, dport=dst_l4) / random_payload(),
+            self.base_ip_packet(is_ip6) / UDP(sport=src_l4, dport=dst_l4) / random_payload(),
+            self.base_ip_packet(is_ip6) / TCP(sport=src_l4, dport=dst_l4+1) / random_payload(),
+        ]
+        self.do_test_one_rule([], [match], [valid], invalid)
+
+        match['is_not'] = True
+        self.do_test_one_rule([], [match], invalid, [valid])
+
+        match = {"is_src": True, "is_not": False, "type": ENTRY_PORT_IP_SET,
+                 "data": {"set_id": {"set_id": self.src_ipport_ipset.vpp_id}}}
+        valid = self.base_ip_packet(is_ip6) / TCP(sport=src_l4, dport=dst_l4) / random_payload()
+        invalid = [ # Change all criteria: address, proto, port
+            self.base_ip_packet(is_ip6, second_src_ip=True) / TCP(sport=src_l4, dport=dst_l4) / random_payload(),
+            self.base_ip_packet(is_ip6) / UDP(sport=src_l4, dport=dst_l4) / random_payload(),
+            self.base_ip_packet(is_ip6) / TCP(sport=src_l4+1, dport=dst_l4) / random_payload(),
+        ]
+        self.do_test_one_rule([], [match], [valid], invalid)
+
+        match['is_not'] = True
+        self.do_test_one_rule([], [match], invalid, [valid])
+
+    # Calico specificity: if a rule has port ranges and ipport ipsets, a packet matches
+    # the rule if it matches either category
+    def test_port_range_and_ipport_ipset_ip6(self):
+            self.test_port_range_and_ipport_ipset(True)
+
+    def test_port_range_and_ipport_ipset(self, is_ip6=False):
+        # Test all match types to exercies all code (but not all combinations)
+        test_port=4569
+        matches = [
+            {"is_src": False, "is_not": False, "type": ENTRY_PORT_IP_SET,
+                "data": {"set_id": {"set_id": self.dst_ipport_ipset.vpp_id}}},
+            {"is_src": False, "is_not": False, "type": ENTRY_PORT_RANGE,
+                "data": {"port_range": {"start": test_port, "end": test_port}}},
+        ]
+        valid = [
+            self.base_ip_packet(is_ip6) / TCP(sport=src_l4, dport=dst_l4) / random_payload(),
+            self.base_ip_packet(is_ip6) / TCP(sport=src_l4, dport=test_port) / random_payload(),
+            self.base_ip_packet(is_ip6) / UDP(sport=src_l4, dport=test_port) / random_payload(),
+            self.base_ip_packet(is_ip6, second_src_ip=True) / TCP(sport=src_l4, dport=test_port) / random_payload(),
+            self.base_ip_packet(is_ip6, second_dst_ip=True) / TCP(sport=src_l4, dport=test_port) / random_payload(),
+        ]
+        invalid = [
+            self.base_ip_packet(is_ip6, second_dst_ip=True) / TCP(sport=src_l4, dport=dst_l4) / random_payload(),
+            self.base_ip_packet(is_ip6) / UDP(sport=src_l4, dport=dst_l4) / random_payload(),
+            self.base_ip_packet(is_ip6) / TCP(sport=src_l4, dport=(dst_l4+test_port)//2) / random_payload(),
+        ]
+        self.do_test_one_rule([], matches, valid, invalid)
+
+        for match in matches:
+            match['is_not'] = True
+        self.do_test_one_rule([], matches, invalid, valid)
+
+        matches = [
+            {"is_src": True, "is_not": False, "type": ENTRY_PORT_IP_SET,
+                "data": {"set_id": {"set_id": self.src_ipport_ipset.vpp_id}}},
+            {"is_src": True, "is_not": False, "type": ENTRY_PORT_RANGE,
+                "data": {"port_range": {"start": test_port, "end": test_port}}},
+        ]
+        valid = [
+            self.base_ip_packet(is_ip6) / TCP(sport=src_l4, dport=dst_l4) / random_payload(),
+            self.base_ip_packet(is_ip6) / TCP(sport=test_port, dport=dst_l4) / random_payload(),
+            self.base_ip_packet(is_ip6) / UDP(sport=test_port, dport=dst_l4) / random_payload(),
+            self.base_ip_packet(is_ip6, second_src_ip=True) / TCP(sport=test_port, dport=dst_l4) / random_payload(),
+            self.base_ip_packet(is_ip6, second_dst_ip=True) / TCP(sport=test_port, dport=dst_l4) / random_payload(),
+        ]
+        invalid = [
+            self.base_ip_packet(is_ip6, second_src_ip=True) / TCP(sport=src_l4, dport=dst_l4) / random_payload(),
+            self.base_ip_packet(is_ip6) / UDP(sport=src_l4, dport=dst_l4) / random_payload(),
+            self.base_ip_packet(is_ip6) / TCP(sport=(src_l4+test_port)//2, dport=dst_l4) / random_payload(),
+        ]
+        self.do_test_one_rule([], matches, valid, invalid)
+
+        for match in matches:
+            match['is_not'] = True
+        self.do_test_one_rule([], matches, invalid, valid)
+
+
+class TestCapoPolicies(BaseCapoTest):
+    """ Calico Policies tests """
+    @classmethod
+    def setUpClass(self):
+        super(TestCapoPolicies, self).setUpClass()
+
+    @classmethod
+    def tearDownClass(self):
+        super(TestCapoPolicies, self).tearDownClass()
+
+    def setUp(self):
+        super(TestCapoPolicies, self).setUp()
+
+    def tearDown(self):
+        super(TestCapoPolicies, self).tearDown()
+
+    def tcp_dport_rule(self, port, action):
+        return VppCapoRule(self, is_v6=False, action=action,
+            filters=[VppCapoFilter(FILTER_TYPE_L4_PROTO, tcp_protocol, True)],
+            matches=[{"is_src": False, "is_not": False, "type": ENTRY_PORT_RANGE,
+                        "data": {"port_range": {"start": port, "end": port}}}]
+        )
+
+    def test_inbound_outbound(self):
+        r = self.tcp_dport_rule(1000, ACTION_ALLOW)
+        r.add_vpp_config()
+        pin = VppCapoPolicy(self, [VppCapoPolicyItem(is_inbound=1, rule_id=r.vpp_id())])
+        pout = VppCapoPolicy(self, [VppCapoPolicyItem(is_inbound=0, rule_id=r.vpp_id())])
+        pin.add_vpp_config()
+        pout.add_vpp_config()
+
+        matching = self.base_ip_packet() / TCP(sport=1, dport=1000) / random_payload()
+        not_matching = self.base_ip_packet() / TCP(sport=1, dport=2000) / random_payload()
+
+        # out policy at src
+        self.configure_policies(self.pg0, [], [pout], [])
+        self.send_test_packets(self.pg0, self.pg1, [matching], [not_matching])
+
+        # policies configured at src + dst
+        self.configure_policies(self.pg1, [pin], [], [])
+        self.send_test_packets(self.pg0, self.pg1, [matching], [not_matching])
+
+        # policies configured at dst
+        self.configure_policies(self.pg0, [], [], [])
+        self.send_test_packets(self.pg0, self.pg1, [matching], [not_matching])
+
+        # no policies
+        self.configure_policies(self.pg1, [], [], [])
+        self.send_test_packets(self.pg0, self.pg1, [matching, not_matching], [])
+
+    def test_default_verdict(self):
+        # If profiles only are configured (pass_id = 0), default is deny
+        # If there are policies + profiles (pass_id > 0), then default is to deny before
+        # evaluating profiles, unless a rule with a PASS target matches
+        rule1 = self.tcp_dport_rule(1000, ACTION_ALLOW)
+        rule2 = self.tcp_dport_rule(2000, ACTION_ALLOW)
+        rule3 = self.tcp_dport_rule(1000, ACTION_DENY)
+        rule4 = self.tcp_dport_rule(1000, ACTION_PASS)
+        rule1.add_vpp_config()
+        rule2.add_vpp_config()
+        rule3.add_vpp_config()
+        rule4.add_vpp_config()
+        policy1 = VppCapoPolicy(self, [VppCapoPolicyItem(is_inbound=1, rule_id=rule1.vpp_id())])
+        policy2 = VppCapoPolicy(self, [VppCapoPolicyItem(is_inbound=1, rule_id=rule2.vpp_id())])
+        policy3 = VppCapoPolicy(self, [VppCapoPolicyItem(is_inbound=1, rule_id=rule3.vpp_id())])
+        policy4 = VppCapoPolicy(self, [VppCapoPolicyItem(is_inbound=1, rule_id=rule4.vpp_id())])
+        policy5 = VppCapoPolicy(self, [
+            VppCapoPolicyItem(is_inbound=1, rule_id=rule4.vpp_id()),
+            VppCapoPolicyItem(is_inbound=1, rule_id=rule3.vpp_id()),
+        ])
+        policy1.add_vpp_config()
+        policy2.add_vpp_config()
+        policy3.add_vpp_config()
+        policy4.add_vpp_config()
+        policy5.add_vpp_config()
+
+        # Test profile default deny: 1 allow rule, pass_id=0
+        self.configure_policies(self.pg1, [], [], [policy1])
+        passing = [self.base_ip_packet() / TCP(sport=1, dport=1000) / random_payload()]
+        dropped = [self.base_ip_packet() / TCP(sport=1, dport=2000) / random_payload()]
+        self.send_test_packets(self.pg0, self.pg1, passing, dropped)
+
+        # Test policy default deny: 1 allow rule, pass_id=1
+        self.configure_policies(self.pg1, [policy1], [], [])
+        self.send_test_packets(self.pg0, self.pg1, passing, dropped)
+
+        # Test that profiles are not executed when policies are configured
+        # 1 allow policy, 1 allow profile, pass_id=1
+        self.configure_policies(self.pg1, [policy1], [], [policy2])
+        self.send_test_packets(self.pg0, self.pg1, passing, dropped)
+
+        # Test that pass target does not evaluate further policies and jumps to profiles
+        # 1 pass policy, 1 deny policy, 1 allow profile, pass_id=2
+        self.configure_policies(self.pg1, [policy4, policy3], [], [policy1])
+        self.send_test_packets(self.pg0, self.pg1, passing, dropped)
+
+        # Test that pass target does not evaluate further rules in the policy and jumps to profiles
+        # 1 policy w/ 1 pass rule & 1 deny rule, 1 deny profile, pass_id=1
+        self.configure_policies(self.pg1, [policy5], [], [policy1])
+        self.send_test_packets(self.pg0, self.pg1, passing, dropped)
+
+        policy1.remove_vpp_config()
+        policy2.remove_vpp_config()
+        policy3.remove_vpp_config()
+        policy4.remove_vpp_config()
+        policy5.remove_vpp_config()
+        rule1.remove_vpp_config()
+        rule2.remove_vpp_config()
+        rule3.remove_vpp_config()
+        rule4.remove_vpp_config()
+
+    def test_realistic_policy(self):
+        # Rule 1 allows ping from everywhere
+        rule1 = VppCapoRule(self, is_v6=False, action=ACTION_ALLOW,
+            filters = [
+                VppCapoFilter(FILTER_TYPE_L4_PROTO, icmp_protocol, True),
+                VppCapoFilter(FILTER_TYPE_ICMP_TYPE, 8, True),
+                VppCapoFilter(FILTER_TYPE_ICMP_CODE, 0, True),
+            ],
+            matches = [],
+        )
+        rule1.add_vpp_config()
+        # Rule 2 allows tcp dport 8080 from a single container
+        src_ipset = VppCapoIpset(self, IPSET_TYPE_NET,
+                [self.pg0.remote_ip4 + "/32", self.pg0.remote_ip6 + "/128"])
+        src_ipset.add_vpp_config()
+        rule2 = VppCapoRule(self, is_v6=False, action=ACTION_ALLOW,
+            filters=[
+                VppCapoFilter(FILTER_TYPE_L4_PROTO, tcp_protocol, True),
+            ],
+            matches = [
+                {"is_src": True, "is_not": False, "type": ENTRY_IP_SET,
+                        "data": {"set_id": {"set_id": src_ipset.vpp_id}}},
+                {"is_src": False, "is_not": False, "type": ENTRY_PORT_RANGE,
+                        "data": {"port_range": {"start": 8080, "end": 8080}}},
+            ],
+        )
+        rule2.add_vpp_config()
+        policy = VppCapoPolicy(self, [
+            VppCapoPolicyItem(is_inbound=1, rule_id=rule1.vpp_id()),
+            VppCapoPolicyItem(is_inbound=1, rule_id=rule2.vpp_id()),
+        ])
+        policy.add_vpp_config()
+        self.configure_policies(self.pg1, [policy], [], [])
+
+        passing = [
+            self.base_ip_packet() / ICMP(type=8),
+            self.base_ip_packet(second_src_ip=True) / ICMP(type=8),
+            self.base_ip_packet() / TCP(sport=1, dport=8080) / random_payload(),
+        ]
+        dropped = [
+            self.base_ip_packet() / ICMP(type=3),
+            self.base_ip_packet(second_src_ip=True) / TCP(sport=1, dport=8080) / random_payload(),
+            self.base_ip_packet() / UDP(sport=1, dport=8080) / random_payload(),
+            self.base_ip_packet() / TCP(sport=1, dport=8081) / random_payload(),
+        ]
+        self.send_test_packets(self.pg0, self.pg1, passing, dropped)
+        # Cleanup
+        self.configure_policies(self.pg1, [], [], [])
+        policy.remove_vpp_config()
+        rule1.remove_vpp_config()
+        rule2.remove_vpp_config()
+        src_ipset.remove_vpp_config()
-- 
2.38.0

